# 第一章 JVM与Java体系结构

## 一，JVM的整体结构

1. ![](F:\截图\屏幕截图 2022-07-22 133114.png)

## 二，JVM的架构模型

Java编译器输入的指令流基本上是一种基于==栈的指令集架构==，另外一种指令集架构则是基于==寄存器的指令集架构==

两种架构之间的区别

- 基于栈式架构的特点
  - 设计和实现更简单，适用于资源受限的系统
  - 避开了寄存器的分配难题：使用零地址指令方式分配。
  - 指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。
  - 不需要硬件支持，可移植性更好，更好实现跨平台
- 基于寄存器的架构特点
  - 典型的应用是x86的二进制指令集：比如传统的PC以及Android的Davlik虚拟机。
  - 指令集架构则完全依赖硬件，可移植性差
  - 性能优秀和执行更高效
  - 花费更少的指令去完成一项操作。
  - 在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主。

由于跨平台性的设计，Java的指令都是根据栈来设计的。不同平台CPU架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。

## 三，JVM的生命周期

1. 虚拟机的启动

   Java虚拟机的启动是通过引导类加载器(bootstrap class loader)创建一个初始类(initial class)来完成的，这个类是由虚拟机的具体实现指定的。

2. 虚拟机的执行

   - 个运行中的Java虚拟机有着一个清晰的任务：执行Java程序。
   - 程序开始执行时他才运行，程序结束时他就停止。
   - 执行一个所谓的Java程序的时候，真真正正在执行的是一个叫做Java虚拟机的进程。

3. 虚拟机的退出

   - 程序正常执行结束
   - 程序在执行过程中遇到了异常或错误而异常终止
   - 由于操作系统出现错误而导致Java虚拟机进程终止
   - 某线程调用Runtime类或System类的exit方法，或Runtime类的halt方法，并且Java安全管理器也允许这次exit或halt操作。
   - 除此之外，JNI(Java Native Interface)规范描述了用JNI Invocation API来加载或卸载Java虚拟机时，Java虚拟机的退出情况。

# 第二章 类加载器与类的加载过程

## 一，类加载器子系统

![](F:\截图\屏幕截图 2022-07-22 155535.png)

1. 类加载器子系统负责从文件系统或者网络中加载class文件，class文件在文件开头有特定的文件标识。
2. ClassLoader只负责class文件的加载，至于它是否可以运行，则由ExecutionEngine决定。
3. 加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是class文件中常量池部分的内存映射)

## 二，类加载过程

![](F:\截图\屏幕截图 2022-07-22 160120.png)

1. 加载
   - 通过一个类的全限定名获取定义此类的二进制字节流
   - 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
   - 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访间入口
2. 链接
   - 验证（Verify）
     - 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性不会危害虚拟机自身安全
     - 主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。
   - 准备（Prepare）
     - 为类变量分配内存并且设置该类变量的默认初始值，即零值。
     - 这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化
     - 这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到java堆中。
   - 解析（Resolve）
     - 将常量池内的符号引用转换为直接引用的过程
     - 事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。
     - 符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄
     - 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等
3. 初始化
   - 初始化阶段就是执行类构造器方法<clinit\>()的过程。此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。
   - 构造器方法中指令按语句在源文件中出现的顺序执行。
   - <clinit\>()不同于类的构造器。（关联：构造器是虚拟机视角下的<init\>()）
   - 若该类具有父类，JVM会保证子类的<clinit\>()执行前，父类的<clinit\>()已经执行完毕。
   - 虚拟机必须保证一个类的<clinit\>()方法在多线程下被同步加锁。

## 三，类的加载器的分类

- JVM支持两种类型的类加载器，分别为引导类加载器(Bootstrap ClassLoader)和自定义类加载器(User-Defined ClassLoader)。

- 从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。

- 无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有3个，如下所示：

  ![](F:\截图\屏幕截图 2022-07-22 173833.png)

- ```java
  public class ClassLoaderTest {
      public static void main(String[] args) {
          ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
          System.out.println(systemClassLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2
          ClassLoader extClassLoader = systemClassLoader.getParent();
          System.out.println(extClassLoader);//sun.misc.Launcher$ExtClassLoader@4554617c
          ClassLoader bootstrapClassLoader = extClassLoader.getParent();
          System.out.println(bootstrapClassLoader);//null
  
          ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
          System.out.println(classLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2-->系统加载器
          ClassLoader stringClassLoader = String.class.getClassLoader();
          System.out.println(stringClassLoader);//null-->引导加载器
      }
  }
  ```

1. 启动类加载器（引导类加载器，Bootstrap ClassLoader）

   - 这个类加载使用C/C++语言实现的，嵌套在JVM内部。
   - 它用来加载Java的核心库(JAVA_HOME/jre/lib/rt.jar、resources.jar或sun.boot.class,path路径下的内容)，用于提供JVM自身需要的类
   - 并不继承自java.lang.ClassLoader,没有父加载器。
   - 加载扩展类和应用程序类加载器，并指定为他们的父类加载器。
   - 出于安全考虑，Bootstrap启动类加载器只加载包名为java、java、sun等开头的类

2. 扩展类加载器（Extension ClassLoader）

   - Java语言编写，由sun.misc.Launcher$ExtclassLoader实现。
   - 派生于ClassLoader类
   - 父类加载器为启动类加载器
   - 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目下，也会自动由扩展类加载器加载。

3. 应用程序加载器（系统类加载器，APPClassLoader）

   - java语言编写，由sun.misc.Launcher.$AppclassLoader实现
   - 派生于ClassLoader类
   - 父类加载器为扩展类加载器
   - 它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库
   - 该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载
   - 通过classLoader#getSystemclassLoader()方法可以获取到该类加载器

4. 自定义加载器

   在java的日常应用程序开发中，类的加载几乎是由上述三种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式

   为什么要自定义类加载器

   - 隔离加载类
   - 修改类加载的方式
   - 扩展加载源
   - 防止源码泄漏

5. 自定义类加载器实现步骤

   - 开发人员可通过继承抽象类java.lang.ClassLoader类的方式，实现自己的类加载器，以满足一些特殊的需求在
   - JDK1.2之前，在自定义类加载器时，总会去继承ClassLoader类并重写loadClass()方法，从而实现自定义的类加载类，但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findclass()方法中
   - 在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。

6. 获取ClassLoader的几种方式

   - 获取当前类的ClassLoader

     clazz.getClassLoader()

   - 获取当前线程上下文的ClassLoader

     Thread.currentThread().getContextClassLoader()

   - 获取系统的ClassLoader

     ClassLoader.getSystemClassLoader()

   - 获取调用者的ClassLoader

     DriverManager.getCallerClassLoader()

## 四，双亲委派机制

Java虚拟机对class文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。

1. 工作原理

   - 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；
   - 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归请求最终将到达顶层的启动类加载器
   - 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式
   - ![](F:\截图\屏幕截图 2022-07-25 102633.png)

2. 双亲委派机制的优势

   - 避免类的重复加载
   - 保护程序安全，防止核心API被随意篡改

3. 沙箱安全机制

   自定义String类，但是在加载自定义String类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载jdk自带的文件(rt.jar包中java\lang\String.class)，报错信息说没有main方法，就是因为加载的是rt.jar包中的String类。这样可以保证对java核心源代码的保护，这就是沙箱安全机制。

## 五，其他

1. 在JVM中表示两个class对象是否为同一个类存在两个必要条件

   - 类的完整类名必须一致，包括包名
   - 加载这个类的ClassLoader（指ClassLoader实例对象）必须相同

   换句话说，在JVM中，即使这两个类对象(class对象)来源同一个Class文件，被同一个虚拟机所加载，但只要加载它们的ClassLoader实例对象不同，那么这两个类对象也是不相等的。

2. 对类加载器的引用

   JVM必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么JVM会将这个类加载器的一个引用的类型信息的一部分保存在方法区中。当解析一个类型到另一个类型的引用的时候，需要保证这两个类型的类加载器是相同的。

3. Java程序对类的使用方式分为：主动使用和被动使用

   主动使用分为七种情况：

   - 创建类的实例
   - 访问某个类或接口的静态变量，或者对该静态变量赋值
   - 调用类的静态方法
   - 反射（比如：Class.forName("java.lang.String")）
   - 初始化一个类的子类
   - Java虚拟机启动时被标明为启动类的类
   - JDK7开始提供的动态语言支持：java.lang.invoke.MethodHandle实例的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic句柄对应的类没有初始化，则初始化

   除了以上七种情况，其他使用Java类的方式都被看作是对类的被动使用，都不会导致类的初始化

# 第三章 运行时数据区内部结构

内存是非常重要的系统资源，是硬盘和CPU的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM内存布局规定了Java在运行过程中内存申请、分配、管理的策略，保证了的高效稳定运行。不同的JVM对于内存的划分方式和管理机制存在着部分差异。结合JVM虚拟机规范，来探讨一下经典的JVM内存布局。

## 一，程序计数器

1. 概述

   JVM中的程序计数寄存器(Program Counter Register)中，1Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。

   这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器(或指令计数器)会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。==JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。==

2. 作用

   PC寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令

   ![](F:\截图\屏幕截图 2022-07-25 111606.png)

3. 介绍

   - 它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。
   - 在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。
   - 任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的Java方法的JVM指令地址：或者，如果是在执行native方法，则是未指定值(undefined)。
   - 它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
   - 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。
   - 它是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

## 二，虚拟机栈

栈是运行时单位，而堆是存储的单位

1. java虚拟机栈是什么

   java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用

2. 生命周期和线程一致

3. 作用

   主管Java程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回

4. 栈的特点（优点）

   - 栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。
   - JVM直接对Java栈的操作只有两个：
     - 每个方法执行，伴随着进栈（入栈、压栈）
     - 执行结束后的出栈工作
   - 对于栈来说不存在垃圾回收问题

5. 栈中可能出现的异常

   Java虚拟机规范允许Java栈的大小是动态的或者是固定不变的。

   - 如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个StackOverflowError异常。
   - 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法中请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出-个OutofMemoryError异常。

6. 栈中存储什么

   - 每个线程都有自己的栈，栈中的数据都是以栈帧(Stack Frame)的格式存在。
   - 在这个线程上正在执行的每个方法都各自对应一个栈帧(Stack Frame)。
   - 栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。

7. 栈运行原理

   - JVM直接对Java栈的操作只有两个，就是对栈帧的压栈和出栈，遵循“先进后出”/“后进先出”原则。
   - 在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为==当前栈帧(Current Frame)==,与当前栈帧相对应的方法就是==当前方法(CurrentMethod)==,定义这个方法的类就是==当前类(Current class)==执行引擎运行的所有字节码指令只针对当前栈帧进行操作。如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。

8. 栈帧的内部结构

   每个栈帧中存储着：

   - 局部变量表(Local Variables)
   - 操作数栈(Operand Stack) (或表达式栈)
   - 动态链接(Dynamic Linking) (或指向运行时常量池的方法引用)
   - 方法返回地址(Return Address) (或方法正常退出或者异常退出的定义)
   - 一些附加信息

### ==局部变量表==

- 局部变量表也被称之为局部变量数组或本地变量表
- 定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量这些数据类型包括各类基木数据类型、对象引用(reference),以及return Address类型。
- 由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题
- 局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。
- 方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。
- 局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。

### 关于Slot的理解

- 参数值的存放总是在局部变量数组的index0开始，到数组长度-1的索引结束。
- 局部变量表，最基本的存储元是Slot（变量槽）
- 局部变量表中存放编译期可知的各种基本数据类型(8种)，引用类型(reference)，returnAddress类型的变量。
- 在局部变量表里，32位以内的类型只占用一个slot(包括returnAddress类型)，64位的类型(long和double)占用两个slot。
  - byte、short、char在存储前被转换为int，boolean也被转换为int，0表示false，非0表示true。
  - long和double则占据两个Slot。
- JVM会为局部变量表中的每一个slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值
- 当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个Slot上
- 如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如：访问long或double类型变量)
- 如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。

**Slot的重复利用**

栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变的糟位，从而达到节省资源的目的。

### 静态变量与局部变量的对比

- 参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。
- 我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。
- 和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。

**补充说明**

- 在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。
- 局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。

### ==操作数栈==

- 每一个独立的栈帧中除了包含局部变量表以外，还包含一个后进先出(Last-In-First-Out)的操作数栈，也可以称之为表达式栈(Expression Stack）
- 操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈(push)/出栈(pop)。
  - 某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。
  - 比如：执行复制、交换、求和等操作
- 操作数栈，主要用于保存计过程的中间结果，同时作为计算过程中变量临时的存储空间。
- 操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。
- 每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值。
- 栈中的任何一个元素都是可以任意的Java数据类型。
  - 32bit的类型占用一个栈单位深度
  - 64bit的类型占用两个栈单位深度
- 操作数栈并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈(push)和出栈(pop)操作来完成一次数据访间。
- 如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。
- 操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。
- 另外，我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈。

### 栈顶缓存（Top-of-Stack Cashing）

前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派(instruction dispatch)次数和内存读/写次数。

由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，Hotspot JVM的设计者们提出了栈项缓存(Tos,Top-of-Stack Cashing)技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。

### ==动态链接==

- 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接(Dynamic Linking)。比如：invokedynamic指令
- 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用(Symbolic Reference)保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。

### 方法的调用

在JVM中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关。

- 静态链接：当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。
- 动态链接：如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。

对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。

- 早期绑定：早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竞是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。
- 晚期绑定：如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。

虚方法与非虚方法

- 如果方法在编译期就确定了具体的调用版木，这个版木在运行时是不可变的。这样的方法称为非虚方法。
- 静态方法、私有方法、final方法、实例构造器、父类方法都是非虚方法。
- 其他方法称为虚方法。

虚方法表

- 在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。因此，为了提高性能，JVM采用在类的方法区建立一个虚方法表(virtual method table)(非虚方法不会出现在表中)来实现。使用索引表来代替查找。
- 每个类中都有一个虚方法表，表中存放着各个方法的实际入口。
- 虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM会把该类的方法表也初始化完毕。

### 方法返回地址

- 存放调用该方法的pc寄存器的值。
- 一个方法的结束，有两种方式
  - 正常执行完成
  - 出现未处理的异常，非正常退
- 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。

## 三，本地方法接口

1. 什么是本地方法

   简单地讲，一个Native Method就是一个Java调用非Java代码的接口。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern "C"告知C++编译器去调用一个C的函数。

   在定义一个native method时，并不提供实现体（有些像定义一个Javainterface),因为其实现体是由非java语言在外面实现的：本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序。

2. 为什么要使用Native Method

   Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。

   - 与Java环境外交互：

     有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。

   - 与操作系统交互：

     JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用c写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。

   - Sun's Java：

     Sun的解释器是用c实现的，这使得它能像一些普通的c一样与外部交互。jre大部分是用ava实现的，它也通过一些本地方法与外界交互。例如：类java.lang,Thread的setpriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setpriority0()。这个本地方法是用c实现的，并被植入JVM内部，在windows95的平台上，这个本地方法最终将调用Win32 Setpriority()API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库(external dynamic link library)提供，然后被JVM调用。

# 第四章 堆

## 一，堆的核心概念

- 一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。
- Java堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。堆内存的大小是可以调节的。
- 《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。
- 所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区(Thread Local，Allocation Buffer，TLAB)
- 《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。(The heap is the un-time data area fromwhich memory for all class instances and arrays is allocated)
- 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。
- 在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。
- 堆，是GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。

## 二，内存细分

1. 在Java7之前堆内存逻辑上分为三部分：新生区+养老区+永久区
2. 在Java8之后堆内存逻辑上分为三部分：新生区+养老区+元空间

## 三，堆空间的大小的设置

- Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，可以通过选项”-Xmx”和”-Xms“来进行设置。
  - “-Xms“用于表示堆区的起始内存，等价-XX:InitialHeapsize
  - “-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapsize
- 一旦堆区中的内存大小超过“-Xmx“所指定的最大内存时，将会抛出OutofMemoryError异常。
- 通常会将-Xms和-Xmx两个参数配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。
- 默认情况下，初始内存大小：物理电脑内存大小/64；最大内存大小：物理电脑内存大小/4

**查看设置的参数**

- 方式一：jps ---> jstat -gc 进程id
- 方式二：添加参数-XX:+PrintGCDetails

## 四，年轻代与老年代

- 存储在JVM中的Java对象可以被划分为两类：
  - 一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速
  - 另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。
- Java堆区进一步细分的话，可以划分为年轻代(YoungGen)和老年代(OldGen)其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区)。

配置新生代与老年代在堆结构的占比。

- 默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3
- 可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5
- 在HotSpot中，Eden空间和另外两个Survivor:空间缺省所占的比例是8：1：1
- 可以通过选项“-XX:SurvivorRatio”调整这个空间比例。比如-XX:SurvivorRatio=8
- 几乎所有的Java对象都是在Eden区被new出来的。
- 绝大部分的Java对象的销毁都在新生代进行了。
- 可以使用选项"-Xmn"设置新生代最大内存大小，这个参数一般使用默认值就可以了

## 五，对象分配的一般过程

为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑GC执行完内存回收后是否会在内存空间中产生内存碎片。

1. new的对象先放伊甸园区。此区有大小限制。
2. 当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收器将对伊甸园区进行垃圾回收(Minor GC),将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区
3. 然后将伊甸园中的剩余对象移动到幸存者0区。
4. 如果再次触发垃圾回收，此时上次幸存下来的放到幸存者0区的，如果没有回收，就会放到幸存者1区
5. 如果再次经历垃圾回收，此时会重新放回幸存者0区，接着再去幸存者1区。
6. 啥时候能去养老区呢？可以设置次数。默认是15次。可以设置参数：                  -XX:MaxTenuringThreshold=<N\>进行设置。
7. ![](F:\截图\屏幕截图 2022-07-27 111530.png)

## 六，Minor GC、Major GC和Full GC

JVM在进行GC时，并非每次都对上面三个内存区域一起回收的，大部分时候回收的都是指新生代。针对HotSpot VM的实现，它里面的GC按照回收区域又分为两大种类型：一种是部分收集(Partial GC)，一种是整堆收集(Full GC)

- 部分收集：不是完整收集整个Java堆的垃圾收集。其中又分为：

  - 新生代收集(Minor GC/Young GC)：只是新生代的垃圾收集

  - 老年代收集(Major GC/Old GC)：只是老年代的垃圾收集。

    目前，只有CMS GC会有单独收集老年代的行为。

    注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。

  - 混合收集(Mixed GC)：收集整个新生代以及部分老年代的垃圾收集。

    目前，只有G1 GC会有这种行为

- 整堆收集(Full GC)：收集整个java堆和方法区的垃圾收集。

年轻代GC（Minor GC）触发机制：

- 当年轻代空间不足时，就会触发Minor GC,这里的年轻代满指的是Eden代满，Survivor满不会引发GC。(每次Minor GC会清理年轻代的内存)
- 因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。
- Minor GC会引发STW,暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行。

老年代GC（Major GC/Full GC）触发机制：

- 指发生在老年代的GC，对象从老年代消失时，我们说“Major GC”或“Full GC”发生了。

- 出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。

  也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC

- Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。

  如果Major GC后，内存还不足，就报OOM了。

Full GC触发机制：

- 调用System.gc()时，系统建议执行Full GC，但是不必然执行
- 老年代空间不足
- 方法区空间不足
- 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
- 由Eden区、survivor space0(From Space)区间survivor space1(To Space)区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

## 七，TLAB（Thread Local Allocation Buffer）

1. 为什么要有TLAB
   - 堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据
   - 由于对象实例的创建在JVM中非常频繁，因此在并发环境下从堆区中划分内存空间是线程不安全的
   - 为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。
2. 什么是TLAB
   - 从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。多线程同时分配内存时，使用TLAB可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为快速分配策略。
   - 所有openJDK衍生出来的JVM都提供了TLAB的设计。
3. TLAB说明
   - 尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选。
   - 在程序中，开发人员可以通过选项“-XX:UseTLAB”设置是否开启TLAB空间。
   - 默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%，当然我们可以通过选项“-XX:TLABWasteTargetPercent”设置TLAB空间所占用Eden空间的百分比大小。
   - 一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。

## 八，堆空间常用的JVM参数

- -XX:+PrintFlagsInitial：查看所有的参数的默认初始值

- -XX:+PrintFlagsFinal：查看所有的参数的最终值（可能会存在修改，不再是初始值）

- 具体查看某个参数的指令：

  jps	查看当前运行中的进程

  jinfo -flag SurvivorRatio 进程id

- -Xms：初始堆空间内存（默认为物理内存1/64）

- -Xmx：最大堆空间内存（默认为物理内存的/4）

- -Xmn：设置新生代的大小（初始值及最大值）

- -XX:NewRatio：配置新生代与老年代在堆结构的占比

- -XX:SurvivorRatio：设置新生代中Eden与S0/Sl空间的比例

- -XX:MaxTenuringThreshold：设置新生代垃圾的最大年龄

- -XX:+PrintGCDetails：输出详细的GC处理日志

- 打印gc简要信.息：-XX:+PrintGC；-verbose:gc

- -XX:HandlePromotionFailure:是否设置空间分配担保

## 九，逃逸分析

1. 逃逸分析概述

   - 如何将堆上的对象分配到栈，需要使用逃逸分析手段。
   - 这是一种可以有效减少Java程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。
   - 通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。
   - 逃逸分析的基本行为就是分析对象动态作用域：
     - 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。
     - 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。

2. 参数设置

   - 在JDK6u23版本之后，HotSpot中默认就已经开启了逃逸分析。
   - 如果使用的是较早的版本，则可以通过：
     - 选项“-XX:+DoEscapeAnalysis“显式开启逃逸分析
     - 通过选项“-XX:+PrintEscapeAnalysis“查看逃逸分析的筛选结果。

3. 代码优化

   - 栈上分配

     将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。

     JIT编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。

   - 同步省略

     如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。

     在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。

   - 分离对象或标量替换

     有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。

     标量(Scalar)是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量相对的，那些还可以分解的数据叫做聚合量(Aggregate)，Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。

     在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。

     标量替换参数设置：参数-XX:+EliminateAllocations开启了标量替换（默认打开)，允许将对象打散分配在栈上。

# 第五章 方法区

## 一，方法的理解

《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于HotSpot JVM而言，方法区还有一个别名叫做Non-Heap(非堆)，目的就是要和堆分开。所以，方法区看作是一块独立于Java堆的内存空间。

- 方法区(Method Area)与Java堆一样，是各个线程共享的内存区域。
- 方法区在JVM启动的时候被创建，并且它的实际的物理内存空间中和Java堆区一样都可以是不连续的。
- 方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。
- 方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：java.lang.OutofMemoryError:PermGen space ；java.lang.OutofMemoryError:Metaspace
- 关闭JVM就会释放这个区域的内存。

## 二，设置方法区的大小与OOM

- 元数据区大小可以使用参数-XX:MetaspaceSize和-XX:MaxMetaspacesize指定，替代上述原有的两个参数。
- 默认值依赖于平台。windows下，-XX:MetaspaceSize是21M，-XX:MaxMetaspacesize的值是-1,即没有限制。
- 与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常OutofMemoryError:Metaspace
- -XX:MetaspaceSize：设置初始的元空间大小。对于一个64位的服务器端JVM来说，其默认的-XX:MetaspaceSize值为21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC将会被触发并卸载没用的类（即这些类对应的类加载器不再存活）然后这个高水位线将会重置。新的高水位线的值取决于GC后释放了多少元空间。如果释放的空间不足，那么在不超过MaxMetaspacesize时，适当提高该值。如果释放空间过多，则适当降低该值。
- 如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到Full GC多次调用。为了避免频繁地GC,建议将-XX:MetaspaceSize设置为一个相对较高的值。

## 三，如何解决OOM

1. 要解决OOM异常或heap space的异常，一般的手段是首先通过内存映像分析工具(如Eclipse Memory Analyzer)对dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)。
2. 如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及GC Roots引用链的信息，就可以比较准确地定位出泄漏代码的位置。
3. 如果不存在内存泄漏，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数(-Xmx与-Xms),与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。

## 四，方法区的内部结构

1. 类信息

   对每个加载的类型（类class、接口interface、枚举enum、注解annotation)，JVM必须在方法区中存储以下类型信息：

   - 这个类型的完整有效名称（全名=包名.类名）
   - 这个类型直接父类的完整有效名（对于interface或是java.lang.object，都没有父类)
   - 这个类型的修饰符(public,abstract,final的某个子集)
   - 这个类型直接接口的一个有序列表

2. 域(Field)信息

   - JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。
   - 域的相关信息包括：域名称、域类型、域修饰符(public,private,protected,static,final,volatile,transient的某个子集)

3. 方法信息

   JVM必须保存所有方法的以下信息，同域信息一样包括声明顶序：

   - 方法名称
   - 方法的返回类型（或void)
   - 方法参数的数量和类型（按顺序）
   - 方法的修饰符(public,private,protected,static,final,synchronized,native,abstract的一个子集)
   - 方法的字节码(bytecodes)、操作数栈、局部变量表及大小(abstract和native方法除外)
   - 异常表(abstract和native方法除外)，每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引

4. non-final的类变量

   - 静态变量和类关联在一起，随着类的加载而加载，它们成为类数据在逻辑上的一部分。
   - 类变量被类的所有实例共享，即使没有类实例时你也可以访问它。

## 五，运行时常量池

- 运行时常量池(Runtime Constant Pool)是方法区的一部分。
- 常量池表(Constant Pool Table)是Class文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。
- 运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。
- JVM为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过索引访问的。
- 运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为真实地址。运行时常量池，相对于Class文件常量池的另一重要特征是：具备动态性。
- 运行时常量池类似于传统编程语言中的符号表(symbol table)，但是它所包含的数据却比符号表要更加丰富一些。
- 当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则JVM会抛DutofMemoryError异常。

## 六，方法区的垃圾回收

- 先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近Java语言层次的常量概念，如文本字符串、被声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：
  - 类和接口的全限定名
  - 字段的名称和描述符
  - 方法的名称和描述符
- HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。
- 回收废弃常量与回收Java堆中的对象非常类似。
- 判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：
  - 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。
  - 加载该类的类加载器已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。
  - 该类对应的java.lang.class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
- Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot,虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:+Traceclass-Loading、-XX:+TraceClassUnLoading查看类加载和卸载信息
- 在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力。

# 第六章 对象的实例化、内存布局与访问定位

## 一，对象的实例化

![](F:\截图\屏幕截图 2022-07-29 162335.png)

## 二，对象的内存布局

![](F:\截图\屏幕截图 2022-07-29 171615.png)

![](F:\截图\屏幕截图 2022-07-29 172504.png)

## 三，对象访问定位

![](F:\截图\屏幕截图 2022-07-29 173030.png)

# 第七章 直接内存

- 不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。

- 直接内存是在Java堆外的、直接向系统申请的内存区间。
- 来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存通常，访问直接内存的速度会优于Java堆。即读写性能高。
  - 因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。
  - Java的NIO库允许Java程序使用直接内存，用于数据缓冲区
- 也可能导致OutOfMemoryError异常
- 由于直接内存在Java堆外，因此它的大小不会直接受限于-Xmx指定的最大堆大小，但是系统内存是有限的，Java堆和直接内存的总和依然受限于操作系统能给出的最大内存。
- 缺点
  - 分配回收成本较高
  - 不受JVM内存回收管理
- 直接内存大小可以通过MaxDirectMemorySize设置
- 如果不指定，默认与堆的最大值-Xmx参数值一致

# 第八章 执行引擎

## 一，执行引擎概述

- 执行引擎是]ava虚拟机核心的组成部分之一。
- “虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。

## 二，Java代码编译和执行的过程

![](F:\截图\屏幕截图 2022-08-01 100251.png)

1. 什么是解释器（Interpreter），什么是JIT编译器

   - 解释器

     当Java虚拟机启动时会根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文中的内容“翻译”为对应平台的本地机器指令执行。

   - JIT(Just In Time Compiler)编译器：

     就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。

2. 解释器

   在Java的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。

   - 字节码解释器在执行时通过纯软件代码模拟字节码的执行，效率非常低下。
   - 而模板解释器将每一条字节码和一个模板函数相关联，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。在HotSpot VM中，解释器主要由Interpreter模块和code模块构成。
     - Interpreter模块：实现了解释器的核心功能
     - Code模块：用于管理HotSpot VM在运行时生成的本地机器指令

3. JIT编译器

   - Java语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个前端编译器（其实叫“编译器的前端”更准确一些）把.java文件转变成.class文件的过程
   - 也可能是指虚拟机的后端运行期编译器(JIT编译器，Just In Time Compiler)把字节码转变成机器码的过程。
   - 还可能是指使用静态提前编译器(AOT编译器，Ahead Of Time Compiler)直接把.java文件编译成本地机器代码的过程。 

4. 热点代码及探测方式

   - 一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”，因此都可以通过JIT编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此也被称之为栈上替换，或简称为OSR(On Stack Replacement)编译。
   - 一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠热点探测功能。
   - ==目前HotSpot VM所采用的热点探测方式是基于计数器的热点探测。==
   - 采用基于计数器的热点探测，HotSpot VM将会为每一个方法都建立2个不同类型的计数器，分别为方法调用计数器(Invocation Counter)和回边计数器(BackEdge Counter)。
   - 方法调用计数器用于统计方法的调用次数；回边计数器则用于统计循环体执行的循环次数

5. 方法调用计数器

   - 这个计数器就用于统计方法被调用的次数，它的默认阈值在Client模式下是1500次，在Server模式下是10000次。超过这个阈值，就会触发JIT编译。
   - 这个阈值可以通过虚拟机参数-XX:CompileThreshold来人为设定。
   - 当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。如果己超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。
   - 如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的衰减(Counter Decay)，而这段时间就称为此方法统计的半衰周期(Counter Half Life Time)
   - 进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数-XX:-UseCounterDecay来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。
   - 另外，可以使用-XX:CounterHalfLifeTime参数设置半衰周期的时间，单位是秒。

6. 回边计数器

   它的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”(Back Edge)。显然，建立回边计数器统计的目的就是为了触发OSR编译。

7. HotSpot VM设置程序执行方式

   HotSpot VM是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，通过命令显式地为Java虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行。如下所示：

   - -Xint：完全采用解释器模式执行程序：
   - -Xcomp:完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行。
   - -Xmixed:采用解释器+即时编译器的混合模式共同执行程序。

# 第九章 String Table

## 一，String的基本特性

1. String：字符串，使用一对""引起来表示
2. String声明为final的，不可被继承
3. String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String可以比较大小
4. String在jdk8及以前内部定义了final char[] value用于存储字符串数据。jdk9时改为byte[]
5. String:代表不可变的字符序列。简称：不可变性
   - 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。
   - 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。
   - 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。
6. 通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。
7. String的String Pool是一个固定大小的Hashtable,默认值大小长度是1009。如果放进String Pool的String非常多，就会造成Hash冲突严重，从而导致链表会很长，而链表长了后直接会造成的影响就是当调用String.intern时性能会大幅下降。
8. 使用-XX:StringTableSize可设置StringTable的长度在jdk6中StringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快。StringTableSize设置没有要求
9. 在jdk7中，StringTable的长度默认值是60013，jdk8中1009是可设置的最小值。

## 二，String的内存分配

1. 在Java语言中有8种基本数据类型和一种比较特殊的类型String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。
2. 常量池就类似一个Java系统级别提供的缓存。8种基本数据类型的常量池都是系统协调的，String类型的常量池比较特殊。它的主要使用方法有两种。
   - 直接使用双引号声明出来的String对象会直接存储在常量池中。比如：String name="wgx";
   - 如果不是用双引号声明的String对象，可以使用String提供的intern()方法。
3. Java6及以前，字符串常量池存放在永久代。
4. Java7中Oracle的工程师对字符串池的逻辑做了很大的改变，即将字符串常量池的位置调整到Java堆内。
   - 所有的字符串都保存在堆(Heap)中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。
   - 字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在Java7中使用String.intern()。
5. Java8元空间，字符串常量在堆

## 三，字符串拼接操作

1. 常量与常量的拼接结果在常量池，原理是编译期优化
2. 常量池中不会存在相同内容的常量。
3. 只要其中有一个是变量，结果就在堆中。变量拼接的原理是StringBuilder
4. 如果拼接的结果调用intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址。

## 四，intern()的使用

如果不用双引号声明的String对象，可以使用String提供的intern方法：intern方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。

- 比如：String myName = new String("wgx").intern();

也就是说，如果在任意字符串上调用String.intern方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是true:("a" + "b" + "c").intern() == "abc"

通俗点讲，Interned String就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池(String Intern Pool）。

**String的intern()使用总结：**

jdk1.6中，将这个字符串对象尝试放入串池。

- 如果串池中有，则并不会放入。返回已有的串池中的对象的地址
- 如果没有，会把==此对象复制一份==，放入串池，并返回串池中的对象地址

jdk1.7起，将这个字符串对象尝试放入串池。

- 如果串池中有，则并不会放入。返回已有的串池中的对象的地址
- 如果没有，则会把==对象的引用地址复制一份==，放入串池，并返回串池中的引用地址

## 五，G1的String去重操作

- 当垃圾收集器工作的时候，会访问堆上存活的对象。对每一个访问的对象都会检查是否是候选的要去重的String对象。
- 如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的String对象。
- 使用一个hashtable来记录所有的被String对象使用的不重复的char数组。当去重的时候，会查这个hashtable,来看堆上是否已经存在一个一模一样的char数组。
- 如果存在，String对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。
- 如果查找失败，char数组会被插入到hashtable,这样以后的时候就可以共享这个数组了。

**命令行选项**

- UseStringDeduplication (bool):开启String去重，默认是不开启的，需要手动开启。
- PrintStringDeduplicationStatistics (bool):打印详细的去重统计信息
- StringDeduplicationAgeThreshold (uintx):达到这个年龄的String对象被认为是去重的候选对象

# 第十章 垃圾回收

## 一，垃圾回收的概述

1. 什么是垃圾

   垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序结束，被保留的空间无法被其他对象使用。甚至可能导致内存溢出。

2. 为什么需要GC

   - 对于高级语言来说，一个基本认知是如果不进行垃圾回收，内存迟早都会被消耗完，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。
   - 除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便JVM将整理出的内存分配给新的对象。
   - 随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，没有GC就不能保证应用程序的正常进行。而经常造成STW的GC又跟不上实际的需求，所以才会不断地尝试对GC进行优化。

3. Java的垃圾回收机制

   - 自动内存管理，无需开发人员手动参与内存的分配与回收，这样降低内存泄漏和内存溢出的风险
   - 自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地专注于业务开发

## 二，垃圾标记阶段算法

1. 引用计数算法

   - 引用计数算法(Reference Counting)比较简单，对每个对象保存一个整型的引用计数器属性。用于记录对象被引用的情况。
   - 对于一个对象A，只要有任何一个对象引用了A，则A的引用计数器就加1；当引用失效时，引用计数器就减1。只要对象A的引用计数器的值为0，即表示对象A不可能再被使用，可进行回收。
   - 优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。
   - 缺点：
     - 它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。
     - 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。
     - 引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。

2. 可达性分析算法

   - 相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。

   - 相较于引用计数算法，这里的可达性分析就是Java、c#选择的。这种类型的垃圾收集通常也叫作追踪性垃圾收集(Tracing Garbage Collection)。

   - 所谓"GC Roots"根集合就是一组必须活跃的引用。

   - 基本思路：

     - 可达性分析算法是以根对象集合(GC Roots)为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达。
     - 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链(Reference Chain)
     - 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。
     - 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。

   - 在Java语言中，GC Roots包括以下几类元素

     - 虚拟机栈中用的对象比如：各个线程被调用的方法中使用到的参数、局部变量等。
     - 本地方法栈内JNI(通常说的本地方法)引用的对象
     - 方法区中类静态属性引用的对象比如：Java类的引用类型静态变量
     - 方法区中常量引用的对象比如：字符串常量池(String Table)里的引用
     - 所有被同步锁synchronized持有的对象
     - Java虚拟机内部的引用。基本数据类型对应的class对象，一些常驻的异常对象（如：NullPointerException、OutofMemoryError)，系统类加载器。
     - 反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

     ==注意==

     如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行。这点不满足的话分析结果的准确性就无法保证。这点也是导致GC进行时必须"Stop The World"的一个重要原因。即使是号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。

## 三，对象的finalization机制

- Java语言提供了对象终止(finalization)机制来允许开发人员提供对象被销毁之前的自定义处理逻辑。
- 当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的finalize()方法。
- finalize()方法允许在子类中被重写，用于在对象被回收时进行资源释放。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。
- 永远不要主动调用某个对象的finalize(),应该交给垃圾回收机制调用。理由包括下面三点：
  - 方法在finalize()时可能会导致对象复活。
  - finalize()方法的执行时间是没有保障的，它完全由GC线程决定，极端情况下，若不发生GC，则finalize()方法将没有执行机会。
  - 一个糟糕的finalize()会严重影响GC的性能。
- 从功能上来说，finalize()方法与c++中的析构函数比较相似，但是Java采用的是基于垃圾回收器的自动内存管理机制，所以finalize()方法在本质上不同于c++中的析构函数。
- 由于finalize()方法的存在，虚拟机中的对象一般处于三种可能的状态。
- 如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。一个无法触及的对象有可能在某一个条件下“复活”自己，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：
  - 可触及的：从根节点开始，可以到达这个对象。
  - 可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活。不可触及的：对象的finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为finalize()只会被调用一次。
- 以上3种状态中，是由于finalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。

## 四，垃圾清除阶段算法

1. 标记-清除（Mark-Sweep）算法

   ![](F:\截图\屏幕截图 2022-08-04 173116.png)

   当堆中的有效内存空间(available memory)被耗尽的时候，就会停止整个程序（也被称为stop the world),然后进行两项工作，第一项则是标记，第二项则是清除。

   - 标记：Collector从引用根节点开始遍历，标记所有被引用的对象。一般是在对象的Header中记录为可达对象。
   - 清除：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收。

   **缺点：**

   - 效率不算高
   - 在进行GC的时候，需要停止整个应用程序，导致用户体验差
   - 这种方式清理出来的空闲内存是不连续的，产生内存碎片。需要维护一个空闲列表

2. 复制（Copying）算法

   ![](F:\截图\屏幕截图 2022-08-04 173309.png)

   将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收。

   **优点：**

   - 没有标记和清除过程，实现简单，运行高效
   - 复制过去以后保证空间的连续性，不会出现“碎片”问题。

   **缺点：**

   - 此算法的缺点也是很明显的，就是需要两倍的内存空间。
   - 对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小。

3. 标记-压缩（Mark-Compact）算法

   ![](F:\截图\屏幕截图 2022-08-04 174916.png)

   第一阶段和标记-清除算法一样从根节点开始标记所有被引用对象；第二阶段将所有的存活对象压缩到内存的一端，按顺序排放；之后，清理边界外所有的空间。

   **优点：**

   - 消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。
   - 消除了复制算法当中，内存减半的高额代价。

   **缺点：**

   - 从效率上来说，标记-整理算法要低于复制算法。
   - 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址。
   - 移动过程中，需要全程暂停用户应用程序。即：STW

4. 小结

   ![](F:\截图\屏幕截图 2022-08-04 175646.png)

## 五，增量收集算法、分区算法

1. 增量收集算法

   如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作。

   **缺点：**

   使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，造成系统吞吐量的下降。

2. 分区算法

   一般来说，在相同条件下，堆空间越大，一次GC时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。

   分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。

## 六，垃圾回收相关概念

1. System.gc()的理解

   - 在默认情况下，通过System.gc()或者Runtime.getRuntime().gc()的调用，会显式触发Full GC,同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。
   - 然而System.gc()调用附带一个免责声明，无法保证对垃圾收集器的调用。
   - JVM实现者可以通过System.gc()调用来决定JVM的GC行为。而一般情况下，垃圾回收应该是自动进行的，无须手动触发，否则就太过于麻烦了。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用System.gc().

2. 内存溢出（OOM）

   - 内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。
   - 由于GC一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收己经跟不上内存消耗的速度，否则不太容易出现OOM的情况。
   - 大多数情况下，GC会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的Full GC操作，这时候会回收大量的内存，供应用程序继续使用。
   - javadoc中对OutOfMemoryError的解释是，没有空闲内存，并且垃圾收集器也无法提供更多内存。
   - 首先说没有空闲内存的情况：说明Java虚拟机的堆内存不够。原因有二：
     - Java虚拟机的堆内存设置不够。比如：可能存在内存泄漏问题：也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定JVM堆大小或者指定数值偏小。我们可以通过参数-Xms、-Xmx来调整。
     - 代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）对于老版本的Oracle JDK,因为永久代的大小是有限的，并且JM对永久代垃圾回收(如，常量池回收、卸载不再需要的类型)非常不积极，所以当我们不断添加新类型的时候，永久代出现OutOfMemoryError也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似intern字符串缓存占用太多空间，也会导致OOM问题。对应的异常信息，会标记出来和永久代相关："java.lang.OutOfMemoryError: PermGen space"。随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的OOM有所改观，出现OOM,异常信息则变成了："java.lang.OutOfMemoryError: Metaspace"。直接内存不足，也会导致OOM

3. 内存泄漏（Memory Leak）

   也称作“存储渗漏”。严格来说，只有对象不会再被程序用到了，但是GC又不能回收他们的情况，才叫内存泄漏。

   但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致OOM,也可以叫做宽泛意义上的“内存泄漏”。

   尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现OutOfMemory异常，导致程序崩溃。

   注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。

4. Stop The World

   - Stop-The-World，简称STW，指的是GC事件发生过程中，会产生应用程序的停顿。停顿产生时整个应用程序线程都会被暂停，没有任何响应，有点像卡死的感觉，这个停顿称为STW。

     可达性分析算法中枚举根节点(GC Roots)会导致所有Java执行线程停顿。

     - 分析工作必须在一个能确保一致性的快照中进行
     - 一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上
     - 如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证

   - 被STW中断的应用程序线程会在完成GC之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少STW的发生。

   - STW事件和采用哪款GC无关，所有的GC都有这个事件。
   - 哪怕是G1也不能完全避免Stop-The-World情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。
   - STW是JVM在后台自动发起和自动完成的。在用户不可见的情况下，把用户正常的工作线程全部停掉。
   - 开发中不要用System.gc();会导致Stop-The-World的发生。

5. 垃圾回收的并行与并发

   - 并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。如，ParNew、Parallel、Scavenge、Parallel Old；
   - 串行（Serial）：相较于并行的概念，单线程执行。如果内存不够，则程序暂停，启动JVM垃圾回收器进行垃圾回收。回收完，再启动程序的线程
   - 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），垃圾回收线程在执行时不会停顿用户程序的运行。用户程序在继续运行，而垃圾收集程序线程运行于另一个CPU上。如，CMS、G1

6. 安全点与安全区域

   - 安全点

     程序执行时并非在所有地方都能停顿下来开始GC,只有在特定的位置才能停顿下来开始GC,这些位置称为“安全点(Safepoint)”。

     Safe Point的选择很重要，如果太少可能导致GC等待的时间太长，如果太频繁可能导致运行时的性能问题。大部分指令的执行时间都非常短暂，通常会根据“是否具有让程序长时间执行的特征”为标准。比如：选择一些执行时间较长的指令作为Safe Point，如方法调用、循环跳转和异常跳转等。

   - 如何在GC发生时，检查所有线程都跑到最近的安全点停顿下来

     - 抢先式中断：（目前没有虚拟机采用了）

       首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。

     - 主动式中断：

       设置一个中断标志，各个线程运行到Safe Point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。

   - 安全区域（Safe Region）

     Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？例如线程处于Sleep状态或Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全点去中断挂起，JVM也不太可能等待线程被唤醒。对于这种情况，就需要安全区域(Safe Region)来解决。

     安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。

   - 实际执行时

     - 当线程运行到Safe Region的代码时，首先标识已经进入了Safe Region,如果这段时间内发生GC，JVM会忽略标识为Safe Region状态的线程
     - 当线程即将离开Safe Region时，会检查JVM是否已经完成GC,如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开Safe Region的信号为止

## 七，Java中几种不同的引用概述

1. 引用概述

   - 强引用(StrongReference):最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj = new object()“这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。
   - 软引用(SoftReference):在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。
   - 弱引用(WeakReference):被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。
   - 虚引用(PhantomReference):一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。

2. 强引用——不回收

   在Java程序中，最常见的引用类型是强引用==（普通系统99%以上都是强引用）==，也就是我们最常见的普通对象引用，也是默认的引用类型

   当在Java语言中使用new操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。

   强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。

   对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为null，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。

   相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，强引用是造成Java内存泄漏的主要原因之一。

3. 软引用——内存不足即回收

   软引用是用来描述一些还有用，但非必需的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。

   软引用通常用来实现内存敏感的缓存。比如：高速缓存就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。

   垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列(Reference Queue)

   类似弱引用，只不过Java虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。

4. 弱引用——发现即回收

   弱引用也是用来描述那些非必需对象，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。在系统GC时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。

   但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。

   弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。

   软引用、弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。

5. 虚引用——对象回收跟踪

   也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。

   一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。

   它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get()方法取得对象时，总是null。

   为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。

   - 虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。
   - 由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。
   - 在JDK1.2版之后提供了PhantomReference类来实现虚引用。

6. 终结器引用

   - 它用以实现对象的finalize()方法，r也可以称为终结器引用。
   - 无需手动编码，其内部配合引用队列使用。
   - 在GC时，终结器引用入队。由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize()方法，第二次GC时才能回收被引用对象。

# 第十一章 垃圾回收器

## 一，GC分类

- 垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的JVM来实现。
- 由于JDK的版本处于高速迭代过程中，因此Java发展至今己经衍生了众多的GC版本。
- 从不同角度分析垃圾收集器，可以将GC分为不同的类型。
- 按==线程==分，可以分为串行垃圾回收器和并行垃圾回收器
  - 串行回收指的是在同一时间段内只允许有一个CPU用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。
    - 在诸如单CPU处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，串行回收默认被应用在客户端的Client模式下的JVM中
    - 在并发能力比较强的CPU上，并行回收器产生的停顿时间要短于串行回收器。
  - 和串行回收相反，并行收集可以运用多个CPU同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-The-World”机制。
- 按==工作模式==分，可以分为并发式垃圾回收器和独占式垃圾回收器
  - 并发式垃圾回收器与应用程序线程交替工作，以尽可能的减少引用程序的停顿时间
  - 独占式垃圾回收器（Stop-The-World）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束
- 按==碎片处理方式==分，可以分为压缩式垃圾回收器和非压缩式垃圾回收器
  - 压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。
  - 非压缩式的垃圾回收器不进行这步操作。
- 按==工作的内存区间==分，可以为分年轻代垃圾回收器和老年代垃圾回收器

## 二，评估GC性能指标

- ==吞吐量==：运行用户代码的时间占总运行时间的比例
  - （总运行时间：程序的运行时间+内存回收的时间）
- 垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。
- ==暂停时间==：执行垃圾收集时，程序的工作线程被暂停的时间。
- 收集频率：相对于应用程序的执行，收集操作发生的频率。
- ==内存占用==：Java堆区所占的内存大小。
- 快速：一个对象从诞生到被回收所经历的时间。

## 三，垃圾回收的组合关系

![](F:\截图\屏幕截图 2022-08-08 102021.png)

1. 两个收集器间有连线，表明它们可以搭配使用：

   Serial/Serial old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1

2. 其中Serial old作为CMS出现"Concurrent Mode Failure"失败的后备预案。

3. (红色虚线)由于维护和兼容性测试的成本，在JDK8时将Serial+CMS、ParNew+Serial old这两个组合声明为废弃(JEP173)，并在JDK9中完全取消了这些组合的支持(JEP214)

4. (绿色虚线)JDK14中：弃用Parallel Scavenge和SerialOld GC组合(JEP366)

5. (青色虚线)JDK14中：删除CMS垃圾回收器(JEP363)

## 四，查看默认的垃圾回收器

- -XX:+PrintCommandLineFlags:查看命令行相关参数（包含使用的垃圾收集器)
- 使用命令行指令：jinfo -flag 相关垃圾回收器参数 进程ID

## 五，Serial回收器（串行回收）

- Serial收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3之前回收新生代唯一的选择。

- Serial收集器作为HotSpot中Client模式下的默认新生代垃圾收集器。

- Serial收集器采用复制算法、串行回收和"Stop-The-World"机制的方式执行内存回收。

- 除了年轻代之外，Serial收集器还提供用于执行老年代垃圾收集的Serial Old收集器。Serial Old收集器同样也采用了串行回收和"Stop The World“机制，只不过内存回收算法使用的是标记-压缩算法。

  - Serial Old是运行在Client模式下默认的老年代的垃圾回收器

  - Serial Old在Server模式下主要有两个用途：

    ①与新生代的ParallelScavenge配合使用

    ②作为老年代CMS收集器的后备垃圾收集方案

- ![](F:\截图\屏幕截图 2022-08-08 110141.png)

- 优势：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。运行在client模式下的虚拟机是个不错的选择。

- 在HotSpot虚拟机中，使用-XX:+UseSerialGC参数可以指定年轻代和老年代都使用串行收集器。等价于新生代用Serial GC,且老年代用Serial Old GC

## 六，ParNew回收器（并行回收）

- 如果说Serial GC是年轻代中的单线程垃圾收集器，那么ParNew收集器则是Serial收集器的多线程版本。

  Par是Parallel的缩写，New:只能处理的是新生代

- ParNew收集器除了采用并行回收的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew收集器在年轻代中同样也是采用复制算法、"Stop-The-World'"机制。

- ParNew是很多JVM运行在Server模式下新生代的默认垃圾收集器。

- ![](F:\截图\屏幕截图 2022-08-08 111719.png)

- ParNew收集器运行在多CPU的环境下，由于可以充分利用多CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。

- 但是在单个CPU的环境下，ParNew收集器不比Serial收集器更高效。虽然Serial收集器是基于串行回收，但是由于CPU不需要频繁地任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销

- 因为除Serial外，目前只有ParNew GC能与CMS收集器配合工作

- 可以通过选项"-XX:+UseParNewGC"手动指定使用ParNew收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。

- -XX:ParallelGCThreads限制线程数量，默认开启和CPU数据相同的线程数。

## 七，Parallel回收器（吞吐量优先）

- HotSpot的年轻代中除了拥有ParNew收集器是基于并行回收的以外，Parallel Scavengel收集器同样也采用了复制算法、并行回收和“Stop-The-World"机制。
- 和ParNew收集器不同，Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量(Throughput)，它也被称为吞吐量优先的垃圾收集器。
- 自适应调节策略也是Parallel Scavenge与ParNew一个重要区别。
- 高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序。
- Parallel收集器在JDK1.6时提供了用于执行老年代垃圾收集的Parallel Old收集器，用来代替老年代的Serial Old收集器。
- Parallel  Old收集器采用了标记-压缩算法，但同样也是基于并行回收和"Stop-The-World"机制。
- 在程序吞吐量优先的应用场景中，Parallel收集器和Parallel Old收集器的组合，在Server模式下的内存回收性能很不错。
- 在Java8中，默认是此垃圾收集器。
- -XX:+UseParallelGC：手动指定年轻代使用Parallel并行收集器执行内存回收任务。
- -XX:+UseParallelOldGC：手动指定老年代使用并行回收收集器。
  - 分别适用于新生代和老年代。默认jdk8是开启的。
  - 上面两个参数，默认开启一个，另一个也会被开启。（互相激活）
- -XX:ParallelGCThreads设置年轻代并行收集器的线程数。一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。
  - 在默认情况下，当CPU数量小于8个，ParallelGCThreads的值等于CPU数量。
  - 当CPU数量大于8个，ParallelGCThreads的值等于3+[5*CPU_Count]/8。
- -XX:MaxGCPauseMills：设置垃圾收集器最大停顿时间（即STW的时间)。单位是毫秒。
  - 为了尽可能地把停顿时间控制在MaxGCPauseMillis以内，收集器在工作时会调整Java堆大小或者其他一些参数。
  - 对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合Parallel，进行控制。
- -XX:GCTimeRatio：垃圾收集时间占总时间的比例(=1/(N+1))用于衡量吞吐量的大小。
  - 取值范围(0,100)。默认值99，也就是垃圾回收时间不超过1%。
  - 与前一个-XX:MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。
- -XX:+UseAdaptiveSizePolicy：设置Parallel Scavenge收集器具有自适应调节策略
  - 在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。
  - 在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量(GCTimeRatio)和停顿时间(MaxGCPauseMillis),让虚拟机自己完成调优工作。

## 八，CMS回收器（低延迟）

- 在JDK1.5时期，HotSpot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器：CMS(Concurrent-Mark-Sweep)收集器，这款收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。
- CMS收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。
  - 目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。
- CMS的垃圾收集算法采用标记-清除算法，并且也会"Stop-The-World”

**CMS工作原理**

![](F:\截图\屏幕截图 2022-08-08 151737.png)

- 初始标记(Initial-Mark)阶段：在这个阶段中，程序中所有的工作线程都将会因为“Stop-The-World”机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。
- 并发标记(Concurrent-Mark)阶段：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。
- 重新标记(Remark)阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。
- 并发清除(Concurrent-Sweep)阶段：此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的

**相关参数**

- -XX:+UseConcMarkSweepGC：手动指定使用CMS收集器执行内存回收任务。
  - 开启该参数后会自动将-XX:+UseParNewGC打开。即：ParNew(Young区用)+CMS(Old区用)+Serial Old的组合。
- -XX:CMSInitiatingOccupanyFraction：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。
  - JDK5及以前版本的默认值为68，即当老年代的空间使用率达到68%时，会执行一次CMS回收。JDK6及以上版本默认值为92%
  - 如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低Full GC的执行次数。
- -XX:+UseCMSCompactAtFullCollection：用于指定在执行完Full GC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。
- -XX:CMSFullGCsBeforeCompaction：设置在执行多少次Full GC后对内存空间进行压缩整理。
- -XX:ParallelCMSThreads：设置CMS的线程数量。
  - CMS默认启动的线程数是(ParallelGCThreads+3)/4，ParallelGCThreads是年轻代并行收集器的线程数。当CPU资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。

## 九，G1回收器（区域化分代式）

1. G1回收器的特点

   - 并行与并发

     - 并行性：G1在回收期间，可以有多个GC线程同时工作，有效利用多核计算能力。此时用户线程STW
     - 并发性：G1拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况

   - 分代收集

     - 从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，年轻代依然有Eden区和Survivor区。但从堆的结构上看，它不要求整个Eden区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。
     - 将堆空间分为若干个区域(Region)，这些区域中包含了逻辑上的年轻代和老年代。
     - 和之前的各类回收器不同，它同时兼顾年轻代和老年代。对比其他回收器，或者工作在年轻代，或者工作在老年代

   - 空间整合

     - CMS：“标记-清除”算法、内存碎片、若干次GC后进行一次碎片整理
     - G1将内存划分为一个个的region。内存的回收是以region作为基本单位的。Region之间是复制算法，但整体上实际可看作是标记-压缩(Mark-Compact)算法，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。尤其是当Java堆非常大的时候，G1的优势更加明显。

   - 可预测的停顿时间模型（软实时soft real-time）

     这是G1相对于CMS的另一大优势，G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。

     - 由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。
     - G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。
     - 相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。

2. G1回收器相关的参数设置

   - -XX:+UseG1GC：手动指定使用G1收集器执行内存回收任务。
   - -XX:G1HeapRegionSize：设置每个Region的大小。值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。
   - -XX:MaxGCPauseMillis：设置期望达到的最大GC停顿时间指标(JVM会尽力实现，但不保证达到)。默认值是200ms
   - -XX:ParallelGCThread：设置STW工作线程数的值。最多设置为8
   - -XX:ConcGCThreads：设置并发标记的线程数。将设置为并行垃圾回收线程数(ParallelGCThreads)的1/4左右。
   - -XX:InitiatingHeapoccupancyPercent：设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。

3. G1的适用场景

   - 面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）
   - 最主要的应用是需要低GC延迟，并具有大堆的应用程序提供解决方案
   - 如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒：(G1通过每次只清理一部分而不是全部的Region的增量式清理来保证每次GC停顿时间不会过长)。
   - 用来替换掉JDK1.5中的CMS收集器，在下面的情况时，使用G1可能比CMS好：
     - 超过50%的Java堆被活动数据占用
     - 对象分配频率或年代提升频率变化很大
     - GC停顿时间过长（长于0.5至1秒）。
   - HotSpot垃圾收集器里，除了G1以外，其他的垃圾收集器使用内置的JVM线程执行GC的多线程操作，而G1 GC可以采用应用线程承担后台运行的GC工作，即当JVM的GC线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。

4. Remember Set

   - 无论G1还是其他分代收集器，JVM都是使用Remembered Set来避免全局扫描
   - 每个Region都有一个对应的Remembered Set
   - 每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作
   - 然后检查将要写入的引用指向的对象是否和该Reference类型数据在不同的Region(其他收集器：检查老年代对象是否引用了新生代对象)
   - 如果不同，通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remembered Set中
   - 当进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set:就可以保证不进行全局扫描，也不会有遗漏。

5. G1回收器垃圾回收过程

   - 年轻代GC

     JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区，当Eden空间耗尽时，G1会启动一次年轻代垃圾回收过程。

     年轻代垃圾回收只会回收Eden区和Survivor区。

     YGC时，首先G1停止应用程序的执行(Stop-The-World),G1创建回收集(collection Set)，回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代Eden区和Survivor区所有的内存分段。

     回收过程如下

     - 第一阶段，扫描根

       根是指static变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同RSet记录的外部引用作为扫描存活对象的入口。

     - 第二阶段，更新RSet

       处理dirty card queue(见备注)中的card，更新RSet。此阶段完成后，RSet可以准确的反映老年代对所在的内存分段中对象的引用。

     - 第三阶段，处理RSet

       识别被老年代对象指向的Eden中的对象，这些被指向的Eden中的对象被认为是存活的对象。

     - 第四阶段，复制对象

       此阶段，对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段，Survivor区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到old区中空的内存分段。如果Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间。

     - 第五阶段，处理引用

       处理Soft，Weak，Phantom，Final，JNI Weak等引用。最终Eden空间的数据为空，GC停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。

   - 并发标记过程

     - 初始标记阶段：标记从根节点直接可达的对象。这个阶段是STW的，并且会触发一次年轻代GC。
     - 根区域扫描(Root Region Scanning)：G1 GC扫描Survivor区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在young GC之前完成。
     - 并发标记(Concurrent Marking)：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被young GC中断。在并发标记阶段，若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。
     - 再次标记(Remark)：由于应用程序持续进行，需要修正上一次的标记结果，是STW的。G1中采用了比CMS更快的初始快照算法：snapshot-at-the-beginning(SATB)。
     - 独占清理(cleanup，STW)：计算各个区域的存活对象和GC回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是STW的。这个阶段并不会实际上去做垃圾的收集
     - 并发清理阶段：识别并清理完全空闲的区域。

   - 混合回收

     当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，该算法并不是一个Old GC，除了回收整个Young Region,还会回收一部分的Old Region。这里需要注意：是一部分老年代，而不是全部老年代。可以选择哪些Old Region进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是Mixed GC并不是Full GC。

     - 并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分8次（可以通过-XX:G1MixedGCCountTarget设置)被回收。
     - 混合回收的回收集(Collection Set)包括八分之一的老年代内存分段，Eden区内存分段，Survivor区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。
     - 由于老年代中的内存分段默认分8次回收，G1会优先回收垃圾多的内存分段。垃圾占内存分段比例越高的，越会被先回收。并且有一个阈值会决定内存分段是否被回收，-XX:G1MixedGCLiveThresholdPercent，默认为65%，意思是垃圾占内存分段比例要达到65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。
     - 混合回收并不一定要进行8次。有一个阈值-XX:G1HeapWastePercent，默认值为1%，意思是允许整个堆内存中有10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于10%，则不再进行混合回收。因为GC会花费很多的时间但是回收到的内存却很少。

## 十，垃圾回收器总结

![](F:\截图\屏幕截图 2022-08-09 155851.png)

## 十一，GC日志分析

1. 相关参数

   - -XX:+PrintGC  输出GC日志。类似：-verbose:gc
   - -XX:+PrintGCDetails  输出GC的详细日志
   - -XX:+PrintGCTimeStamps  输出GC的时间戳（以基准时间的形式）
   - -XX:+PrintGCDateStamps  输出GC的时间戳（以日期的形式，如2013-05-04T21:53:59.234+0800)
   - -XX:+PrintHeapAtGC  在进行GC的前后打印出堆的信息
   - -xloggc:../logs/gc.log  日志文件的输出路径

2. 数据分析

   ![](F:\截图\屏幕截图 2022-08-09 163545.png)

   <img src="F:\截图\屏幕截图 2022-08-09 164457.png">

