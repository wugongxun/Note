# 第一章 七大设计原则

## 一，设计模式的目的

编写软件过程中，程序员面临着来自（耦合性）内聚性以及可维护性，可扩展性，重用性，灵活性等多方面的挑战，设计模式是为正程序（软件），具有更好

- 代码重用性
- 可读性
- 可扩展性
- 可靠性
- 高内聚，低耦合的特性

## 二，单一职责原则

1. 基本介绍

   对类来说的，即一个类应该只负责一如类A负责两个不同职责：职责1，职责2。当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为 A1，A2

2. 案例

   - ```java
     //违反单一职责原则
     public class SingleResponsibility {
         public static void main(String[] args) {
             Vehicle vehicle = new Vehicle();
             vehicle.run("car");
             vehicle.run("plane");
         }
     }
     
     class Vehicle {
         public void run(String vehicle) {
             System.out.println(vehicle + " is running...");
         }
     }
     ```

   - ```java
     //遵守单一职责原则，但是改动太大
     public class SingleResponsibility {
         public static void main(String[] args) {
             RoadVehicle roadVehicle = new RoadVehicle();
             roadVehicle.run("car");
             AirVehicle airVehicle = new AirVehicle();
             airVehicle.run("plane");
         }
     }
     
     class RoadVehicle {
         public void run(String vehicle) {
             System.out.println(vehicle + " is running...");
         }
     }
     
     class AirVehicle {
         public void run(String vehicle) {
             System.out.println(vehicle + " is flying...");
         }
     }
     ```

3. 注意事项和细节
   - 降低类的复杂度，一个类只负责一项职责。
   - 提高类的可读性，可维护性
   - 降低变更引起的风险
   - 通常情沉下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则

## 三，接口隔离原则

1. 基本介绍

   客户端不应该依赖它不需要的接口，即一个类对另二个类的依赖应该建立在最小的接口上

2. 案例

   ```java
   interface Interface1 {
       void operation1();
   }
   
   interface Interface2 {
       void operation2();
       void operation3();
   }
   
   interface Interface3 {
       void operation4();
       void operation5();
   }
   
   class A {
       public void depend1(Interface1 i) {
           i.operation1();
       }
       public void depend2(Interface2 i) {
           i.operation2();
       }
       public void depend3(Interface2 i) {
           i.operation3();
       }
   }
   
   class C {
       public void depend1(Interface1 i) {
           i.operation1();
       }
       public void depend4(Interface3 i) {
           i.operation4();
       }
       public void depend5(Interface3 i) {
           i.operation5();
       }
   }
   
   class B implements Interface1, Interface2 {
       @Override
       public void operation1() {
           System.out.println("B 实现了 operation1");
       }
   
       @Override
       public void operation2() {
           System.out.println("B 实现了 operation2");
       }
   
       @Override
       public void operation3() {
           System.out.println("B 实现了 operation3");
       }
   }
   
   class D implements Interface1, Interface3 {
       @Override
       public void operation1() {
           System.out.println("D 实现了 operation1");
       }
   
       @Override
       public void operation4() {
           System.out.println("D 实现了 operation4");
       }
   
       @Override
       public void operation5() {
           System.out.println("D 实现了 operation5");
       }
   }
   ```

## 四，依赖倒转（倒置）原则

1. 基本介绍

   - 高层模块应该依赖低层模块，二者都应该依赖其抽象
   - 抽象不应该依赖细节，细节应该依赖抽象
   - 依赖倒转（倒置）的中心思想是面向接口编程
   - 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类
   - 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成

2. 案例

   ```java
   public class DependenceInversion {
       public static void main(String[] args) {
           Person person = new Person();
           person.receive(new Email());
           person.receive(new Message());
       }
   }
   
   interface Receivable {
       void getInfo();
   }
   
   class Email implements Receivable {
       @Override
       public void getInfo() {
           System.out.println("email info...");
       }
   }
   
   class Message implements Receivable {
       @Override
       public void getInfo() {
           System.out.println("message info...");
       }
   }
   
   class Person {
       public void receive(Receivable receivable) {
           receivable.getInfo();
       }
   }
   ```

3. 注意事项和细节

   - 低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好
   - 变量的声明类型尽量是抽象类或接口，这我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化
   - 继承时遵循里氏替换原则

## 五，里氏替换原则

## 六，开闭原则

## 七，迪米特法则

## 八，合成复用原则