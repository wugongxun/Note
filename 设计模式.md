# 第一章 七大设计原则

## 一，设计模式的目的

编写软件过程中，程序员面临着来自（耦合性）内聚性以及可维护性，可扩展性，重用性，灵活性等多方面的挑战，设计模式是为正程序（软件），具有更好

- 代码重用性
- 可读性
- 可扩展性
- 可靠性
- 高内聚，低耦合的特性

## 二，单一职责原则

1. 基本介绍

   对类来说的，即一个类应该只负责一如类A负责两个不同职责：职责1，职责2。当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为 A1，A2

2. 案例

   - ```java
     //违反单一职责原则
     public class SingleResponsibility {
         public static void main(String[] args) {
             Vehicle vehicle = new Vehicle();
             vehicle.run("car");
             vehicle.run("plane");
         }
     }
     
     class Vehicle {
         public void run(String vehicle) {
             System.out.println(vehicle + " is running...");
         }
     }
     ```

   - ```java
     //遵守单一职责原则，但是改动太大
     public class SingleResponsibility {
         public static void main(String[] args) {
             RoadVehicle roadVehicle = new RoadVehicle();
             roadVehicle.run("car");
             AirVehicle airVehicle = new AirVehicle();
             airVehicle.run("plane");
         }
     }
     
     class RoadVehicle {
         public void run(String vehicle) {
             System.out.println(vehicle + " is running...");
         }
     }
     
     class AirVehicle {
         public void run(String vehicle) {
             System.out.println(vehicle + " is flying...");
         }
     }
     ```

3. 注意事项和细节
   - 降低类的复杂度，一个类只负责一项职责。
   - 提高类的可读性，可维护性
   - 降低变更引起的风险
   - 通常情沉下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则

## 三，接口隔离原则

1. 基本介绍

   客户端不应该依赖它不需要的接口，即一个类对另二个类的依赖应该建立在最小的接口上

2. 案例

   ```java
   interface Interface1 {
       void operation1();
   }
   
   interface Interface2 {
       void operation2();
       void operation3();
   }
   
   interface Interface3 {
       void operation4();
       void operation5();
   }
   
   class A {
       public void depend1(Interface1 i) {
           i.operation1();
       }
       public void depend2(Interface2 i) {
           i.operation2();
       }
       public void depend3(Interface2 i) {
           i.operation3();
       }
   }
   
   class C {
       public void depend1(Interface1 i) {
           i.operation1();
       }
       public void depend4(Interface3 i) {
           i.operation4();
       }
       public void depend5(Interface3 i) {
           i.operation5();
       }
   }
   
   class B implements Interface1, Interface2 {
       @Override
       public void operation1() {
           System.out.println("B 实现了 operation1");
       }
   
       @Override
       public void operation2() {
           System.out.println("B 实现了 operation2");
       }
   
       @Override
       public void operation3() {
           System.out.println("B 实现了 operation3");
       }
   }
   
   class D implements Interface1, Interface3 {
       @Override
       public void operation1() {
           System.out.println("D 实现了 operation1");
       }
   
       @Override
       public void operation4() {
           System.out.println("D 实现了 operation4");
       }
   
       @Override
       public void operation5() {
           System.out.println("D 实现了 operation5");
       }
   }
   ```

## 四，依赖倒转（倒置）原则

1. 基本介绍

   - 高层模块应该依赖低层模块，二者都应该依赖其抽象
   - 抽象不应该依赖细节，细节应该依赖抽象
   - 依赖倒转（倒置）的中心思想是面向接口编程
   - 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类
   - 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成

2. 案例

   ```java
   public class DependenceInversion {
       public static void main(String[] args) {
           Person person = new Person();
           person.receive(new Email());
           person.receive(new Message());
       }
   }
   
   interface Receivable {
       void getInfo();
   }
   
   class Email implements Receivable {
       @Override
       public void getInfo() {
           System.out.println("email info...");
       }
   }
   
   class Message implements Receivable {
       @Override
       public void getInfo() {
           System.out.println("message info...");
       }
   }
   
   class Person {
       public void receive(Receivable receivable) {
           receivable.getInfo();
       }
   }
   ```

3. 注意事项和细节

   - 低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好
   - 变量的声明类型尽量是抽象类或接口，这我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化
   - 继承时遵循里氏替换原则

## 五，里氏替换原则

1. 基本介绍
   - 如果对每个类型为T1的对象o1，都有类型为T2的对象o2,使得以T1定义的所有程序 P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。在
   - 使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法
   - 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。

## 六，开闭原则

1. 基本介绍

   - 开闭原则(Open Closed Principle)是编程中最基础、最重要的设计原则
   - 一个软件实体如类，模块和函数应该对扩展开放，对修改关闭。用抽象构建框架，用实现扩展细节。
   - 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。
   - 编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。

2. 案例

   ```java
   //违背OCP原则，如果需要添加新的图形，需要修改使用方
   public class Ocp {
       public static void main(String[] args) {
           GraphicEditor editor = new GraphicEditor();
           editor.drawShape(new Rectangle());
           editor.drawShape(new Circle());
       }
   }
   
   class Shape {
       int type;
   }
   
   class Rectangle extends Shape {
       public Rectangle() {
           super.type = 1;
       }
   }
   
   class Circle extends Shape {
       public Circle() {
           super.type = 2;
       }
   }
   
   class GraphicEditor {
       public void drawShape(Shape shape) {
           if (shape.type == 1) {
               System.out.println("绘制矩形");
           } else if (shape.type == 2) {
               System.out.println("绘制圆形");
           }
       }
   }
   ```

   ```java
   //符合ocp原则
   public class Ocp {
       public static void main(String[] args) {
           GraphicEditor editor = new GraphicEditor();
           editor.drawShape(new Rectangle());
           editor.drawShape(new Circle());
       }
   }
   
   abstract class Shape {
       abstract void draw();
   }
   
   class Rectangle extends Shape {
       @Override
       public void draw() {
           System.out.println("绘制矩形");
       }
   }
   
   class Circle extends Shape {
       @Override
       public void draw() {
           System.out.println("绘制圆形");
       }
   }
   
   class GraphicEditor {
       public void drawShape(Shape shape) {
           shape.draw();
       }
   }
   ```

## 七，迪米特法则

1. 基本介绍

   - 一个对象应该对其他对象保持最少的了解
   - 类与类关系越密切，耦合度越大
   - 迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public方法，不对外泄露任何信息
   - 迪米特法则还有个更简单的定义：只与直接的朋友通信
   - ==直接的朋友==：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现**成员变量**，**方法参数**，**方法返回值**中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。

2. 案例

   ```java
   public class Demeter {
       public static void main(String[] args) {
           SchoolManager schoolManager = new SchoolManager();
           schoolManager.printAllEmployees(new EmployeeManager());
       }
   }
   
   class Employee {
       int id;
   }
   
   class EmployeeManager {
       public List<Employee> getEmployees() {
           ArrayList<Employee> employees = new ArrayList<>();
           for (int i = 0; i < 10; i++) {
               Employee employee = new Employee();
               employee.id = i;
               employees.add(employee);
           }
           return employees;
       }
   }
   
   class SchoolManager {
       public void printAllEmployees(EmployeeManager employeeManager) {
           //违反了迪米特法则，应为Employee不是SchoolManager的直接朋友，不应该直接使用Employee
           List<Employee> employees = employeeManager.getEmployees();
   
           for (Employee employee : employees) {
               System.out.println(employee.id);
           }
       }
   }
   ```

   ```java
   public class Demeter {
       public static void main(String[] args) {
           SchoolManager schoolManager = new SchoolManager();
           schoolManager.printAllEmployees(new EmployeeManager());
       }
   }
   
   class Employee {
       int id;
   }
   
   class EmployeeManager {
       public List<Employee> getEmployees() {
           ArrayList<Employee> employees = new ArrayList<>();
           for (int i = 0; i < 10; i++) {
               Employee employee = new Employee();
               employee.id = i;
               employees.add(employee);
           }
           return employees;
       }
   
       public void printAllEmployees() {
           List<Employee> employees = getEmployees();
   
           for (Employee employee : employees) {
               System.out.println(employee.id);
           }
       }
   }
   
   class SchoolManager {
       public void printAllEmployees(EmployeeManager employeeManager) {
           //遵守迪米特法则，EmployeeManager是SchoolManager的直接朋友，可以使用
           employeeManager.printAllEmployees();
       }
   }
   ```

3. 注意事项和细节

   - 迪米特法则的核心是降低类之间的耦合
   - 由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间（对象间）耦合关系，并不是要求完全没有依赖天系

## 八，合成复用原则

1. 基本介绍

   原则是尽量使用合成/聚合的方式，而不是使用继承

# 第二章 UML类图

## 一，基本介绍

1. UML——Unified modeling language UML(统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果
2. UML本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等
3. 使用UML来建模，常用的工具有Rational Rose，也可以使用一些插件来建模

## 二，类与类之间的关系

1. 依赖

   只要是类中使用到了对方，那么他们之间就存在依赖关系。如果没有对方，连编译都通过不了

   ![](F:\截图\屏幕截图 2023-04-11 160332.png)

2. 泛化

   泛化关系实际上就是继承关系，他是依赖关系的特例

   ![](F:\截图\屏幕截图 2023-04-11 160606.png)

3. 实现

   实现关系实际上就是A类实现了B类，他是依赖关系的特例

   ![](F:\截图\屏幕截图 2023-04-11 161045.png)

4. 关联

   关联关系实际上就是类与类之间的联系，他是依赖关系的特例

   关联具有导航性：即双向关系或单向关系

   关联具有多重性：如

5. 聚合

   聚合关系（Aggregation）表示的是整体和部分的关系，整体与部分可以分开。聚合关系是关联关系的特例，所以他具有关联关系的导航性与多重性

   如：一台电脑由键盘、显示器、鼠标等组成，组成电脑的各个配件是可以从电脑上分离出来的

   ![](F:\截图\屏幕截图 2023-04-11 161949.png)

6. 组合

   组合也是整体与部分的关系，但是整体与部分不可以分开

   ![](F:\截图\屏幕截图 2023-04-11 162355.png)

# 第三章 单例模式

1. 基本介绍

   所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（静态方法）。

2. 饿汉式（静态常量）

   - 构造器私有化

   - 类的内部创建对象

   - 对外暴露一个静态的公共方法

   - ```java
     class Singleton1 {
         //构造器私有化
         private Singleton1() {}
         //类的内部创建对象
         private final static Singleton1 instance = new Singleton1();
         //对外暴露一个静态的公共方法
         public static Singleton1 getInstance() {
             return instance;
         }
     }
     ```

   优缺点：

   - 这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。
   - 在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，在单例模式中大多数都是调用getInstance方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance就没有达到lazy loading的效果

3. 饿汉式（静态代码块）

   ```java
   class Singleton2 {
       private static Singleton2 instance;
       //构造器私有化
       private Singleton2() {}
       static {
           instance = new Singleton2();
       }
       //对外暴露一个静态的公共方法
       public static Singleton2 getInstance() {
           return instance;
       }
   }
   ```

4. 懒汉式（线程不安全）

   ```java
   class Singleton3 {
       private static Singleton3 instance;
       private Singleton3() {}
       public static Singleton3 getInstance() {
           if (instance == null) {
               instance = new Singleton3();
           }
           return instance;
       }
   }
   ```

   优缺点：

   - 起到了Lazy Loading的效果，但是只能在单线程下使用
   - 如果在多线程下，一个线程进入了if判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式

5. 懒汉式（线程安全，同步方法）

   ```java
   class Singleton4 {
       private static Singleton4 instance;
       private Singleton4() {}
       public synchronized static Singleton4 getInstance() {
           if (instance == null) {
               instance = new Singleton4();
           }
           return instance;
       }
   }
   ```

   优缺点：

   - 解决了线程不安全问题
   - 效率太低了，每个线程在想获得类的实例时侯候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低

6. 懒汉式（线程安全，双重检查）

   ```java
   class Singleton5 {
       private static volatile Singleton5 instance;
       private Singleton5() {}
       public static Singleton5 getInstance() {
           if (instance == null) {
               synchronized (Singleton5.class) {
                   if (instance == null) {
                       instance = new Singleton5();
                   }
               }
           }
           return instance;
       }
   }
   ```

   优缺点分析：

   - Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两次`if (instance = null)`检查，这样就可以保证线程安全了。
   - 这样，实例化代码只用执行一次，后面再次访问时，判断`if (singleton = null)`,直接return实例化对象，也避免的反复进行方法同步

7. 静态内部类

   ```java
   class Singleton6 {
       //构造器私有化
       private Singleton6() {}
       private static class Singleton {
           private static final Singleton instance = new Singleton();
       }
       public static Singleton getInstance() {
           return Singleton.instance;
       }
   }
   ```

   优缺点：

   - 这种方式采用了类装载的机制来保证初始化实例时只有一个线程。
   - 静态内部类方式在Singleton6类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载Singleton类，从而完成Singleton的实例化
   - 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。

8. 枚举

   ```java
   public class SingletonType7 {
       public static void main(String[] args) {
           System.out.println(Singleton7.INSTANCE == Singleton7.INSTANCE);
       }
   }
   
   enum Singleton7 {
       INSTANCE
   }
   ```

   优缺点：

   - 这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。
   - 这种方式是Effective Java作者Josh Bloch提倡的方式

9. 单例模式注意事项和细节说明

   - 单例模式保证了系统内在中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能
   - 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new
   - 单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多（即：重量级对象），但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象（比如数据源、session工厂等）

# 第四章 工厂模式

## 一，简单工厂模式

1. 基本介绍

   - 简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式
   - 简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为（代码）
   - 在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式

2. 披萨案例

   - 披萨抽象类

     ```java
     public abstract class Pizza {
         private String name;
     
         public abstract void prepare();
     
         public void make() {
             System.out.println("make " + name + " pizza");
         }
     
         public void cut() {
             System.out.println("cut " + name + " pizza");
         }
     
         public void box() {
             System.out.println("box " + name + " pizza");
         }
     
         public void setName(String name) {
             this.name = name;
         }
     }
     ```

   - 披萨实现类

     ```java
     public class GreekPizza extends Pizza {
         @Override
         public void prepare() {
             System.out.println("prepare GreekPizza...");
         }
     }
     ```

     ```java
     public class CheesePizza extends Pizza{
         @Override
         public void prepare() {
             System.out.println("prepare CheesePizza...");
         }
     }
     ```

   - 披萨工厂

     ```java
     public static Pizza createPizza(String type) {
         Pizza pizza = null;
         if (type.equals("greek")) {
             pizza = new GreekPizza();
             pizza.setName("greek");
         } else if (type.equals("cheese")) {
             pizza = new CheesePizza();
             pizza.setName("cheese");
         }
         return pizza;
     }
     ```

## 二，工厂方法模式

1. 基本介绍

   - 工厂方法模式设计方案：将披萨项目由实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。
   - 工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。

2. 披萨案例

   - 披萨抽象类

     ```java
     public abstract class Pizza {
         private String name;
     
         public abstract void prepare();
     
         public void make() {
             System.out.println("make " + name + " pizza");
         }
     
         public void cut() {
             System.out.println("cut " + name + " pizza");
         }
     
         public void box() {
             System.out.println("box " + name + " pizza");
         }
     
         public void setName(String name) {
             this.name = name;
         }
     }
     ```

   - 披萨实现类

     ```java
     public class BJCheesePizza extends Pizza {
         @Override
         public void prepare() {
             System.out.println("prepare Beijing's CheesePizza...");
         }
     }
     ```

     ```java
     public class BJGreekPizza extends Pizza {
         @Override
         public void prepare() {
             System.out.println("prepare Beijing's GreekPizza...");
         }
     }
     ```

     ......

   - 工厂抽象方法

     ```java
     public abstract class PizzaFactory {
         public abstract Pizza createPizza(String type);
     }
     ```

   - 工厂实现类

     ```java
     public class BJPizzaFactory extends PizzaFactory {
         @Override
         public Pizza createPizza(String type) {
             Pizza pizza = null;
             if (type.equals("greek")) {
                 pizza = new BJGreekPizza();
                 pizza.setName("Beijing's greek");
             } else if (type.equals("cheese")) {
                 pizza = new BJCheesePizza();
                 pizza.setName("Beijing's cheese");
             }
             return pizza;
         }
     }
     ```

     ```java
     public class LDPizzaFactory extends PizzaFactory {
         @Override
         public Pizza createPizza(String type) {
             Pizza pizza = null;
             if (type.equals("greek")) {
                 pizza = new LDGreekPizza();
                 pizza.setName("London's greek");
             } else if (type.equals("cheese")) {
                 pizza = new LDCheesePizza();
                 pizza.setName("London's cheese");
             }
             return pizza;
         }
     }
     ```

## 三，抽象工厂模式

1. 基本介绍

   - 抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类
   - 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。
   - 从设计层面看，抽象工模式就是对简单工厂模式的改进（或者称为进一步的抽象）。
   - 将工厂抽象成两层，AbsFactory(抽象工厂)和具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。

2. 披萨案例

   - 抽象工厂

     ```java
     public interface PizzaFactory {
         Pizza createPizza(String type);
     }
     ```

   - 使用

     ```java
     public class PizzaStore {
         public static void main(String[] args) {
             Scanner scanner = new Scanner(System.in);
             //使用时根据创建具体的实现类得到不同的工厂
             PizzaFactory factory = getFactory(new BJPizzaFactory());
             while (true) {
                 System.out.println("what pizza you want~~~");
                 String type = scanner.nextLine();
                 Pizza pizza = factory.createPizza(type);
                 if (pizza == null) {
                     break;
                 }
                 pizza.prepare();
                 pizza.make();
                 pizza.cut();
                 pizza.box();
                 System.out.println("----------------------");
             }
         }
     
         public static PizzaFactory getFactory(PizzaFactory pizzaFactory) {
             return pizzaFactory;
         }
     }
     ```

# 第五章 原型模式

1. 基本介绍

   - 原型模式(Prototype模式)是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象
   - 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节工作
   - 原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即对象.clone()

2. 通过继承Cloneable接口实现

   ```java
   public class Sheep implements Cloneable {
       private String name;
       private int age;
       private String color;
   
       public Sheep(String name, int age, String color) {
           this.name = name;
           this.age = age;
           this.color = color;
       }
   
       @Override
       public String toString() {
           return "Sheep{" +
                   "name='" + name + '\'' +
                   ", age=" + age +
                   ", color='" + color + '\'' +
                   '}';
       }
   
       @Override
       protected Sheep clone() {
           Sheep clone = null;
           try {
               clone = (Sheep) super.clone();
           } catch (CloneNotSupportedException e) {
               e.printStackTrace();
           }
           return clone;
       }
   }
   ```

3. 深拷贝

   - 通过重写clone方法实现深拷贝

     ```java
     public class Sheep implements Cloneable {
         public String name;
         public int age;
         public String color;
         public Sheep family;
     
         public Sheep(String name, int age, String color) {
             this.name = name;
             this.age = age;
             this.color = color;
         }
     
         @Override
         public String toString() {
             return "Sheep{" +
                     "name='" + name + '\'' +
                     ", age=" + age +
                     ", color='" + color + '\'' +
                     ", family=" + family +
                     '}';
         }
     
         @Override
         protected Sheep clone() {
             Sheep clone = null;
             try {
                 //先拷贝基本数据类型
                 clone = (Sheep) super.clone();
                 //拷贝对象
                 if (clone.family != null) {
                     clone.family = clone.family.clone();
                 }
             } catch (CloneNotSupportedException e) {
                 e.printStackTrace();
             }
             return clone;
         }
     }
     ```

   - 通过序列化方式

     ```java
     try  {
         ByteArrayOutputStream bos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(bos);
         oos.writeObject(sheep);
     
         ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
         ObjectInputStream ois = new ObjectInputStream(bis);
         Sheep clone = (Sheep) ois.readObject();
     } catch (Exception e) {
         throw new RuntimeException(e);
     }
     ```

4. 注意事项和细节

   - 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率
   - 不用重新初始化对象，而是动态地获得对象运行时的状态
   - 如果原始对象发生变化（增加或者减少属性），其它克隆对象的也会发生相应的变化，无需修改代码
   - 在实现深克隆的时候可能需要比较复杂的代码
   - 缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了ocp即原则

# 第六章 建造者模式

1. 基本介绍

   - 建造者模式(Builder Pattern)又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。
   - 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。

2. 建造者模式的四个角色

   - Product（产品角色）：一个具体的产品对象。
   - Builder（抽象建造者）：建一个Product对象的各个部件指定的接口。 
   - ConcreteBuilder（具体建造者）：实现接口，构建和装配各个部件。 
   - Director（指挥者）：构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。

3. 案例

   - 产品角色

     ```java
     public class House {
         private String basic;
         private String wall;
         private String roofed;
     
         public String getBasic() {
             return basic;
         }
     
         public void setBasic(String basic) {
             this.basic = basic;
         }
     
         public String getWall() {
             return wall;
         }
     
         public void setWall(String wall) {
             this.wall = wall;
         }
     
         public String getRoofed() {
             return roofed;
         }
     
         public void setRoofed(String roofed) {
             this.roofed = roofed;
         }
     
         @Override
         public String toString() {
             return "House{" +
                     "basic='" + basic + '\'' +
                     ", wall='" + wall + '\'' +
                     ", roofed='" + roofed + '\'' +
                     '}';
         }
     }
     ```

   - 抽象建造者

     ```java
     public abstract class HouseBuilder {
         protected House house = new House();
     
         public abstract void buildBasic();
         public abstract void buildWalls();
         public abstract void roofed();
         public House build() {
             return house;
         }
     }
     ```

   - 具体建造者

     ```java
     public class CommonHouseBuilder extends HouseBuilder {
     
         @Override
         public void buildBasic() {
             System.out.println("普通房子的地基");
         }
     
         @Override
         public void buildWalls() {
             System.out.println("普通房子的墙");
         }
     
         @Override
         public void roofed() {
             System.out.println("普通房子封顶");
         }
     }
     ```

   - 指挥者

     ```java
     public class HouseDirector {
         HouseBuilder houseBuilder = null;
     
         public HouseDirector(HouseBuilder houseBuilder) {
             this.houseBuilder = houseBuilder;
         }
     
         public void setHouseBuilder(HouseBuilder houseBuilder) {
             this.houseBuilder = houseBuilder;
         }
     
         public House constructHouse() {
             houseBuilder.buildBasic();
             houseBuilder.buildWalls();
             houseBuilder.roofed();
             return houseBuilder.build();
         }
     }
     ```

4. 注意事项和细节

   - 客户端（使用程序）不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象

   - 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象

   - 可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程

   - 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”

   - 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建者模式，因此其使用范围受到一定的限制。如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式

   - 抽象工厂模式VS建造者模式

     抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品

# 第七章 适配器模式

1. 基本介绍

   - 适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)
   - 适配器模式属于结构型模式
   - 主要分为三类：类适配器模式、对象适配器模式、接口适配器模式

2. 类适配器

   - 案例

     ```java
     public class Voltage220V {
         public int output() {
             int src = 220;
             System.out.println("输出电压" + src + "v");
             return src;
         }
     }
     
     public interface Voltage5V {
         int output();
     }
     
     public class VoltageAdapter extends Voltage220V implements Voltage5V {
         @Override
         public int output() {
             int src = super.output();
             int target = src / 44;
             return target;
         }
     }
     
     public class Phone {
         public void charging(Voltage5V voltage5V) {
             if (voltage5V.output() <= 5) {
                 System.out.println("充电~~~~~");
             } else if (voltage5V.output() > 5) {
                 System.out.println("电压过高，无法充电");
             }
         }
     }
     ```

   - 注意事项和细节

     - Java是单继承机制，所以类适配器需要继承src类算是一个缺点，因为这要求target必须是接口，有一定局限性
     -  src类的方法在Adapter中都会暴露出来，也增加了使用的成本。
     - 由于其继承了src类，所以它可以根据需求重写src类的方法，使得Adapter的灵活性增强了。

3. 对象适配器

   - 基本介绍

     - 基本思路和类的适配器模式相同，只是将Adapter类作修改，不是继承src类，而是持有src类的实例，以解决兼容性的问题。即：持有src类，实现target类接口，完成src->dst的适配
     - 根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系。
     - 对象适配器模式是适配器模式常用的一种

   - 案例

     ```java
     public class VoltageAdapter implements Voltage5V {
         Voltage220V voltage220V = new Voltage220V();
     
         @Override
         public int output() {
             int src = voltage220V.output();
             int target = src / 44;
             return target;
         }
     }
     ```

   - 注意事项和细节

     - 对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。根据合成复用原则，使用组合替代继承，所以它解决了类适配器必须继承src的局限性问题，也不再要求target必须是接口。
     - 使用成本更低，更灵活。

4. 接口适配器

   - 基本介绍

     - 一些书籍称为：适配器模式(Default Adapter Pattern)或缺省适配器模式。
     - 当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求
     - 适用于一个接口不想使用其所有的方法的情况。

   - 案例

     ```java
     public interface Interface {
         void m1();
         void m2();
         void m3();
         void m4();
     }
     
     public abstract class AbsAdapter implements Interface {
         @Override
         public void m1() {}
     
         @Override
         public void m2() {}
     
         @Override
         public void m3() {}
     
         @Override
         public void m4() {}
     }
     
     AbsAdapter adapter = new AbsAdapter() {
         @Override
         public void m1() {
             System.out.println("m1~~~");
         }
     };
     
     adapter.m1();
     ```

# 第八章 桥接模式

1. 基本介绍

   - 桥接模式(Bridge模式)是指：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。
   - 是一种结构型设计模式
   - Bridge模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展

2. 案例

   - 品牌接口

     ```java
     public interface Brand {
         void open();
         void close();
         void call();
     }
     ```

   - 品牌实现类

     ```java
     public class XiaoMi implements Brand {
         @Override
         public void open() {
             System.out.println("小米手机，开机");
         }
     
         @Override
         public void close() {
             System.out.println("小米手机，关机");
         }
     
         @Override
         public void call() {
             System.out.println("小米手机，打电话");
         }
     }
     ```

     ```java
     public class Vivo implements Brand {
         @Override
         public void open() {
             System.out.println("Vivo手机，开机");
         }
     
         @Override
         public void close() {
             System.out.println("Vivo手机，关机");
         }
     
         @Override
         public void call() {
             System.out.println("Vivo手机，打电话");
         }
     }
     ```

   - 手机类型抽象类

     ```java
     public abstract class Phone {
         private Brand brand;
     
         public Phone(Brand brand) {
             this.brand = brand;
         }
     
         public void open() {
             this.brand.open();
         }
     
         public void close() {
             this.brand.close();
         }
     
         public void call() {
             this.brand.call();
         }
     }
     ```

   - 手机类型实现类

     ```java
     public class FoldedPhone extends Phone {
         public FoldedPhone(Brand brand) {
             super(brand);
         }
     
         @Override
         public void open() {
             System.out.println("折叠手机");
             //通过调用父类的方法，调用到品牌的方法
             super.open();
         }
     
         @Override
         public void close() {
             System.out.println("折叠手机");
             super.close();
         }
     
         @Override
         public void call() {
             System.out.println("折叠手机");
             super.call();
         }
     }
     ```

3. 注意事项和细节

   - 实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。
   - 对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。
   - 桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。
   - 桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程
   - 桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围有一定的局限性，即需要有这样的应用场景。

# 第九章 装饰者模式

1. 基本介绍

   - 装饰者模式：动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性，装饰者模式他体现了开闭原则(ocp)

2. 案例

   - 抽象类（Component）

     ```java
     public abstract class Drink {
         private String des;
         private float price;
     
         public String getDes() {
             return des;
         }
     
         public void setDes(String des) {
             this.des = des;
         }
     
         public float getPrice() {
             return price;
         }
     
         public void setPrice(float price) {
             this.price = price;
         }
     
         public abstract float cost();
     }
     ```

   - 咖啡抽象类（缓冲层）

     ```java
     public class Coffee extends Drink {
         @Override
         public float cost() {
             return super.getPrice();
         }
     
         @Override
         public String getDes() {
             return super.getDes() + super.getPrice() + "$";
         }
     }
     ```

   - 咖啡具体实现类（被装饰者）

     ```java
     public class Espresso extends Coffee {
         public Espresso() {
             super.setDes("意大利咖啡");
             super.setPrice(20F);
         }
     }
     ```

     ```java
     public class Americano extends Coffee {
         public Americano() {
             super.setDes("美式咖啡");
             super.setPrice(15F);
         }
     }
     ```

   - 装饰者

     ```java
     public class Decorator extends Drink {
         private Drink drink;
     
         public Decorator(Drink drink) {
             this.drink = drink;
         }
     
         @Override
         public float cost() {
             return super.getPrice() + drink.cost();
         }
     
         @Override
         public String getDes() {
             return super.getDes() + super.getPrice() + "$ " + drink.getDes();
         }
     }
     ```

   - 具体的调料

     ```java
     public class Chocolate extends Decorator {
     
         public Chocolate(Drink drink) {
             super(drink);
             super.setDes("巧克力");
             super.setPrice(3F);
         }
     }
     ```

     ```java
     public class Milk extends Decorator {
         public Milk(Drink drink) {
             super(drink);
             super.setDes("牛奶");
             super.setPrice(2F);
         }
     }
     ```

3. ![](F:\截图\屏幕截图 2023-04-15 150424.png)

# 第十章 组合模式

1. 基本介绍
   - 组合模式(Composite Pattern)，又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示“整体-部分”的层次关系。
   - 组合模式依据树形结构来组合对象，用来表示部分以及整体层次。
   - 这种类型的设计模式属于结构型模式。
   - 组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象

2. 案例

   - 组织的抽象类

     ```java
     public abstract class OrganizationComponent {
         private String name;
         private String des;
     
         public OrganizationComponent(String name, String des) {
             this.name = name;
             this.des = des;
         }
     
         public void add(OrganizationComponent organizationComponent) {
             throw new UnsupportedOperationException();
         }
     
         public void remove(OrganizationComponent organizationComponent) {
             throw new UnsupportedOperationException();
         }
     
         public abstract void print();
     
         public String getName() {
             return name;
         }
     
         public void setName(String name) {
             this.name = name;
         }
     
         public String getDes() {
             return des;
         }
     
         public void setDes(String des) {
             this.des = des;
         }
     }
     ```

   - 非叶子节点的实现类

     ```java
     public class University extends OrganizationComponent {
     
         List<OrganizationComponent> organizationComponents = new ArrayList<>();
     
         public University(String name, String des) {
             super(name, des);
         }
     
         @Override
         public void add(OrganizationComponent organizationComponent) {
             organizationComponents.add(organizationComponent);
         }
     
         @Override
         public void remove(OrganizationComponent organizationComponent) {
             organizationComponents.remove(organizationComponent);
         }
     
         @Override
         public void print() {
             System.out.println("=============" + getName() + "============");
             for (OrganizationComponent organizationComponent : organizationComponents) {
                 organizationComponent.print();
             }
         }
     }
     ```

     ```java
     public class College extends OrganizationComponent {
         List<OrganizationComponent> organizationComponents = new ArrayList<>();
     
         public College(String name, String des) {
             super(name, des);
         }
     
         @Override
         public void add(OrganizationComponent organizationComponent) {
             organizationComponents.add(organizationComponent);
         }
     
         @Override
         public void remove(OrganizationComponent organizationComponent) {
             organizationComponents.remove(organizationComponent);
         }
     
         @Override
         public void print() {
             System.out.println("=============" + getName() + "============");
             for (OrganizationComponent organizationComponent : organizationComponents) {
                 organizationComponent.print();
             }
         }
     }
     ```

   - 叶子节点

     ```java
     public class Department extends OrganizationComponent {
         public Department(String name, String des) {
             super(name, des);
         }
     
         @Override
         public void print() {
             System.out.println(getName());
         }
     }
     ```

3. 注意事项和细节

   - 简化客户端操作。客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题。
   - 具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动
   - 方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构
   - 需要遍历组织机构，或者处理的对象具有树形结构时，非常适合使用组合模式
   - 要求较高的抽象性，如果节点和叶子有很多差异性的话，比如很多方法和属性都不一样，不适合使用组合模式

# 第十一章 外观模式

1. 基本介绍

   - 外观模式(Facade)，也叫过程模式外观模式为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用
   - 外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节

2. 案例

   - 子系统

     ```java
     public class DVDPlayer {
         private DVDPlayer() {
             if (instance != null) {
                 throw new RuntimeException("对象已经被创建");
             }
         }
         private static DVDPlayer instance = new DVDPlayer();
     
         public static DVDPlayer getInstance() {
             return instance;
         }
         public void on() {
             System.out.println("DVD on...");
         }
         public void off() {
             System.out.println("DVD off...");
         }
         public void play() {
             System.out.println("DVD play...");
         }
         public void pause() {
             System.out.println("DVD pause...");
         }
     }
     ```

     ```java
     public class Projector {
         private Projector() {
             if (instance != null) {
                 throw new RuntimeException("对象已经被创建");
             }
         }
         private static Projector instance = new Projector();
     
         public static Projector getInstance() {
             return instance;
         }
         public void on() {
             System.out.println("Projector on...");
         }
         public void off() {
             System.out.println("Projector off...");
         }
         public void play() {
             System.out.println("Projector play...");
         }
         public void pause() {
             System.out.println("Projector pause...");
         }
     }
     ```

   - 统一调用的接口

     ```java
     public class HomeTheatreFacade {
         private DVDPlayer dvdPlayer;
         private Projector projector;
     
         public HomeTheatreFacade() {
             dvdPlayer = DVDPlayer.getInstance();
             projector = Projector.getInstance();
         }
     
         public void on() {
             dvdPlayer.on();
             projector.on();
         }
     
         public void off() {
             dvdPlayer.off();
             projector.off();
         }
     
         public void play() {
             dvdPlayer.play();
             projector.play();
         }
     
         public void pause() {
             dvdPlayer.pause();
             projector.pause();
         }
     }
     ```

3. 注意事项和细节

   - 外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复杂性
   - 外观模式对客户端与子系统的耦合关系，让子系统内部的模块更易维护和扩展
   - 通过合理的使用外观模式，可以帮我们更好的划分访问的层次
   - 当系统需要进行分层设计时，可以考虑使用Facade模式
   - 在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个Facade类，来提供遗留系统的比较清晰简单的接口，让新系统与Facade类交互，提高复用性
   - 不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。要以让系统有层次，利于维护为目的。

# 第十二章 享元模式

1. 基本介绍

   - 享元模式（Flyweight Pattern）也叫蝇量模式：运用共享技术有效地支持大量细粒度的对象

   - 常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个
   - 享元模式能够解决重复对象的内存浪费的问题，当系统中有大量相似对象，需要缓冲池时。不需总是创建新对象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率
   - 享元模式经典的应用场景就是池技术，String常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式

2. 内部状态和外部状态

   - 享元模式提出了两个要求：细粒度和共享对象。即将对象的信息分为两个部分：内部状态和外部状态
   - 内部状态指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变
   - 外部状态指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态。

3. 案例

   - 抽象类

     ```java
     public abstract class WebSite {
         public abstract void use();
     }
     ```

   - 实现类

     ```java
     public class ConcreteWebSite extends WebSite {
         private String type;
     
         public ConcreteWebSite(String type) {
             this.type = type;
         }
     
         @Override
         public void use() {
             System.out.println("网站类型为:" + type);
         }
     }
     ```

   - 工厂类

     ```java
     public class WebSiteFactory {
         private Map<String, ConcreteWebSite> pool = new HashMap<>();
     
         public WebSite getWebSite(String type) {
             if (!pool.containsKey(type)) {
                 pool.put(type, new ConcreteWebSite(type));
             }
             return pool.get(type);
         }
     }
     ```

4. 注意事项和细节

   - 在享元模式这样理解，“享”就表示共享，“元”表示对象
   - 系统中有大量对象，这些对象消耗大量内存，并且对象的状态大部分可以外部化时，我们就可以考虑选用享元模式
   - 用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象，用 HashMap/HashTable存储
   - 享元模式大大减少了对象的创建，降低了程序内存的占用，提高效率
   - 享元模式提高了系统的复杂度。需要分离出内部状态和外部状态，而外部状态具有固化特性，不应该随着内部状态的改变而改变，这是我们使用享元模式需要注意的地方
   - 使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制。
   - 享元模式经典的应用场景是需要缓冲池的场景，比如String常量池、数据库连接池

# 第十三章 代理模式

基本介绍

- 代理模式：为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对家访问目标对象，这样做的好处是可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能。
- 被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象
- 代理模式有不同的形式，主要有三种静态代理、动态代理(JDK代理)和Cglib代理。

## 一，静态代理

1. 基本介绍

   静态代理在使用时，需要定义接口或者父类，被代理对象（即目标对象）与代理对象一起实现相同的接口或者是继承相同父类

2. 案例

   - 代理接口

     ```java
     public interface ITeacherDao {
         void teach();
     }
     ```

   - 目标对象（被代理对象）

     ```java
     public class TeacherDao implements ITeacherDao {
         @Override
         public void teach() {
             System.out.println("授课中~~~");
         }
     }
     ```

   - 代理对象

     ```java
     public class TeacherDaoProxy implements ITeacherDao {
         private TeacherDao target;
     
         public TeacherDaoProxy(TeacherDao target) {
             this.target = target;
         }
     
         @Override
         public void teach() {
             System.out.println("代理对象开始代理");
             target.teach();
             System.out.println("授课结束");
         }
     }
     ```

3. 优缺点

   - 优点：在不修改目标对象的功能前提下，能通过代理对象对目标功能扩展
   - 缺点：因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类一旦接口增加方法，目标对象与代理对象都要维护

## 二，动态代理

1. 基本介绍

   - 代理对象，不需要实现接口，但是目标对象要实现接口，否则不能用动态代理
   - 代理对象的生成，是利用DK的API，动态的在内存中构建代理对象
   - 动态代理也叫做：JDK代理、接口代理

2. 案例

   ```java
   public class ProxyFactory {
       private Object target;
   
       public ProxyFactory(Object target) {
           this.target = target;
       }
   
       public Object getProxyInstance() {
           Class<?> aClass = target.getClass();
           return Proxy.newProxyInstance(aClass.getClassLoader(), aClass.getInterfaces(), (proxy, method, args) -> {
               System.out.println("JDK代理开始...");
               Object returnVal = method.invoke(target, args);
               System.out.println("JDK代理结束...");
               return returnVal;
           });
       }
   }
   ```

## 三，Cglib代理

1. 基本介绍

   - 静态代理和JDK代理模式都要求目标对象是实现一个接口，但是有时候目标对象只是一个单独的对象，并没有实现任何的接口，这个时候可使用目标对象子类来实现代理-这就是Cglib代理
   -  Cglib代理也叫作子类代理，它是在内存中构建一个子类对象从而实现对目标对象功能扩展，有些书也将Cglib代理归属到动态代理。
   -  Cglib是一个强大的高性能的代码生成包，它可以在运行期扩展java类与实现java接口。它广泛的被许多AOP的框架使用，例如Spring AOP，实现方法拦截
   - 在AOP编程中如何选择代理模式： 
     - 目标对象需要实现接口，用JDK代理
     - 目标对象不需要实现接口，用Cgib代理
   - Cgib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类

2. 案例

   ```java
   public class ProxyFactory implements MethodInterceptor {
       private Object target;
   
       public ProxyFactory(Object target) {
           this.target = target;
       }
   
       public Object getProxyInstance() {
           Enhancer enhancer = new Enhancer();
           enhancer.setSuperclass(target.getClass());
           enhancer.setCallback(this);
           return enhancer.create();
       }
   
       @Override
       public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
           System.out.println("Cglib代理前...");
           Object returnVal = method.invoke(target, args);
           System.out.println("Cglib代理后...");
           return returnVal;
       }
   }
   ```

# 第十四章 模板方法模式

1. 基本介绍

   - 模板方法模式(Template Method Pattern)，又叫模板模式(Template Pattern)，在一个抽象类公开定义了执行它的方法的模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。
   - 简单说，模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤
   - 这种类型的设计模式属于行为型模式。

2. 案例

   - 抽象类

     ```java
     public abstract class SoyaBeanMilk {
         final void make() {
             select();
             addCondiments();
             soak();
             beat();
         }
     
         void select() {
             System.out.println("挑选新鲜的黄豆");
         }
     
         abstract void addCondiments();
     
         void soak() {
             System.out.println("浸泡黄豆");
         }
     
         void beat() {
             System.out.println("将黄豆和配料放入豆浆机，打豆浆");
         }
     }
     ```

   - 实现类

     ```java
     public class RedBeanSoyaMilk extends SoyaBeanMilk {
         @Override
         void addCondiments() {
             System.out.println("加入红豆");
         }
     }
     ```

     ```java
     public class PeanutSoyaMilk extends SoyaBeanMilk {
         @Override
         void addCondiments() {
             System.out.println("加入花生");
         }
     }
     ```

3. 钩子方法

   在模板方法模式的父类中，我们可以定义一个方法，它默认不做任何事，子类可以视情况要不要覆盖它，该方法称为“钩子”。

   ```java
   public abstract class SoyaBeanMilk {
       final void make() {
           select();
           if (!isPureSoyaMilk()) {
               addCondiments();
           }
           soak();
           beat();
       }
   
       void select() {
           System.out.println("挑选新鲜的黄豆");
       }
   
       abstract void addCondiments();
   
       void soak() {
           System.out.println("浸泡黄豆");
       }
   
       void beat() {
           System.out.println("将黄豆和配料放入豆浆机，打豆浆");
       }
   
       //是否为纯豆浆
       boolean isPureSoyaMilk() {
           return false;
       }
   }
   ```

   ```java
   public class PureSoyaMilk extends SoyaBeanMilk {
       @Override
       void addCondiments() {
   
       }
       @Override
       boolean isPureSoyaMilk() {
           return true;
       }
   }
   ```

4. 注意事项和细节

   - 基本思想是：算法只存在于一个地方，也就是在父类中，容易修改。需要修改算法时，只要修改父类的模板方法或者已经实现的某些步骤，子类就会继承这些修改
   - 实现了最大化代码复用。父类的模板方法和已实现的某些步骤会被子类继承而直接使用。
   - 既统一了算法，也提供了很大的灵活性。父类的模板方法确保了算法的结构保持不变，同时由子类提供部分步骤的实现。
   - 该模式的不足之处：每一个不同的实现都需要一个子类实现，导致类的个数增加，使得系统更加庞大一般模板方法都加上final关键字，防止子类重写模板方法
   - 模板方法模式使用场景：当要完成在某个过程，该过程要执行一系列步骤，这一系列的步骤基本相同，但其个别步骤在实现时可能不同，通常考虑用模板方法模式来处理

# 第十五章 命令模式

1. 基本介绍

   - 命令模式(Command Pattern)：在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计
   - 命名模式使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活，实现解耦。
   - 在命名模式中，会将一个请求封装为一个对象，以便使用不同参数来表示不同的请求（即命名），同时命令模式也支持可撤销的操作。

2. 案例

   - Command抽象类

     ```java
     public interface Command {
         void execute();
         void undo();
     }
     ```

   - 电灯的开关命令

     ```java
     public class LightOnCommand implements Command {
         private LightReceiver light;
     
         public LightOnCommand(LightReceiver light) {
             this.light = light;
         }
     
         @Override
         public void execute() {
             light.on();
         }
     
         @Override
         public void undo() {
             light.off();
         }
     }
     ```

     ```java
     public class LightOffCommand implements Command {
         private LightReceiver light;
     
         public LightOffCommand(LightReceiver light) {
             this.light = light;
         }
     
         @Override
         public void execute() {
             light.off();
         }
     
         @Override
         public void undo() {
             light.on();
         }
     }
     ```

   - 空命令

     ```java
     public class NoCommand implements Command {
         @Override
         public void execute() {
     
         }
     
         @Override
         public void undo() {
     
         }
     }
     ```

   - 电灯命令接受者

     ```java
     public class LightReceiver {
         public void on() {
             System.out.println("电灯打开了...");
         }
         public void off() {
             System.out.println("电灯关闭了...");
         }
     }
     ```

   - 遥控器

     ```java
     public class RemoteController {
         private Command[] onCommands;
         private Command[] offCommands;
         private Command undoCommand;
     
         public RemoteController() {
             onCommands = new Command[5];
             offCommands = new Command[5];
             for (int i = 0; i < 5; i++) {
                 onCommands[i] = new NoCommand();
                 offCommands[i] = new NoCommand();
             }
         }
     
         public void setCommand(int no, Command onCommand, Command offCommand) {
             onCommands[no] = onCommand;
             offCommands[no] = offCommand;
         }
     
         public void onButtonPushed(int no) {
             onCommands[no].execute();
             undoCommand = onCommands[no];
         }
     
         public void offButtonPushed(int no) {
             offCommands[no].execute();
             undoCommand = offCommands[no];
         }
     
         public void undo() {
             undoCommand.undo();
         }
     
     }
     ```

3. 注意事项和细节

   - 将发起请求的对象与执行请求的对象解耦。发起请求的对象是调用者，调用者只要调用命令对象的execute()方法就可以让接收者工作，而不必知道具体的接收者对象是谁、是如何实现的，命令对象会负责让接收者执行请求的动作，也就是说：”请求发起者”和“请求执行者”之间的解耦是通过命令对象实现的，命令对象起到了纽带桥梁的作用。
   - 容易设计一个命令队列。只要把命令对象放到列队，就可以多线程的执行命令容易
   - 实现对请求的撤销和重做
   - 命令模式不足：可能导致某些系统有过多的具体命令类，增加了系统的复杂度，这点在在使用的时候要注意
   - 空命令也是一种设计模式，它为我们省去了判空的操作。在上面的实例中，如果没有用空命令，我们每按下一个按键都要判空，这给我们编码带来一定的麻烦
   - 命令模式经典的应用场景：界面的一个按钮都是一条命令、模拟CMD（DOS命令）订单的撤销/恢复、触发-反馈机制

# 第十六章 访问者模式

1. 基本介绍

   - 访问者模式(Visitor Pattern)，封装一些作用于某种数据结构的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。
   - 主要将数据结构与数据操作分离，解决数据结构和操作耦合性问题
   - 访问者模式的基本工作原理是：在被访问的类里面加一个对外提供接待访问者的接口
   - 访问者模式主要应用场景是：需要对一个对象结构中的对象进行很多不同操作(这些操作彼此没有关联)，同时需要避免让这些操作"污染"这些对象的类，可以选用访问者模式解决

2. 案例

   - 抽象的访问者

     ```java
     public abstract class Action {
         public abstract void getManResult(Man man);
         public abstract void getWomanResult(Woman woman);
     }
     ```

   - 具体的访问者

     ```java
     public class Success extends Action {
         @Override
         public void getManResult(Man man) {
             System.out.println("男人给出成功评价");
         }
     
         @Override
         public void getWomanResult(Woman woman) {
             System.out.println("女人给出成功评价");
         }
     }
     ```

     ```java
     public class Fail extends Action {
         @Override
         public void getManResult(Man man) {
             System.out.println("男人给出失败评价");
         }
     
         @Override
         public void getWomanResult(Woman woman) {
             System.out.println("女人给出失败评价");
         }
     }
     ```

   - 被访问者的抽象类

     ```java
     public abstract class Person {
         abstract void accept(Action action);
     }
     ```

   - 被访问者实现类

     ```java
     public class Man extends Person {
         @Override
         void accept(Action action) {
             action.getManResult(this);
         }
     }
     ```

     ```java
     public class Woman extends Person {
         @Override
         void accept(Action action) {
             action.getWomanResult(this);
         }
     }
     ```

   - 数据结构

     ```java
     public class ObjectStructure {
         private List<Person> persons = new ArrayList<>();
     
         public void attach(Person person) {
             persons.add(person);
         }
     
         public void detach(Person person) {
             persons.remove(person);
         }
     
         public void display(Action action) {
             persons.forEach(person -> {
                 person.accept(action);
             });
         }
     }
     ```

3. 优点

   - 访问者模式符合单一职责原则、让程序具有优秀的扩展性、灵活性非常高
   - 访问者模式可以对功能进行统一，可以做报表、UI、拦截器与过滤器，适用于数据结构相对稳定的系统

4. 缺点

   - 具体元素对访问者公布细节，也就是说访问者关注了其他类的内部细节，这是迪米特法则所不建议的，这样造成了具体元素变更比较困难
   - 违背了依赖倒转原则。访问者依赖的是具体元素，而不是抽象元素
   - 因此，如果一个系统有比较稳定的数据结构，又有经常变化的功能需求，那么访问者模式就是比较合适的

# 第十七章 迭代器模式

1. 基本介绍

   - 迭代器模式(Iterator Pattern)是常用的设计模式，属于行为型模式
   - 如果我们的集合元素是用不同的方式实现的，有数组，还有集合类，或者还有其他方式，当客户端要遍历这些集合元素的时候就要使用多种遍历方式，而且还会暴露元素的内部结构，可以考虑使用迭代器模式解决。
   - 迭代器模式，提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示，即：不暴露其内部的结构。

2. 案例

   - 遍历的元素

     ```java
     public class Department {
         private String name;
         private String desc;
     
         public Department(String name, String desc) {
             this.name = name;
             this.desc = desc;
         }
     
         public String getName() {
             return name;
         }
     
         public void setName(String name) {
             this.name = name;
         }
     
         public String getDesc() {
             return desc;
         }
     
         public void setDesc(String desc) {
             this.desc = desc;
         }
     }
     ```

   - 迭代器抽象类

     ```java
     public interface Iterator<T> {
         boolean hasNext();
         T next();
         void remove();
     }
     ```

   - 迭代器实现类

     ```java
     public class ComputerCollegeIterator implements Iterator<Department> {
         private Department[] departments;
         private int position = 0;
         private int size;
     
         public ComputerCollegeIterator(Department[] departments) {
             this.departments = departments;
             this.size = Arrays.stream(departments).mapToInt(item -> item == null ? 0 : 1).sum();
         }
     
         @Override
         public boolean hasNext() {
             return departments != null && position < size;
         }
     
         @Override
         public Department next() {
             return departments[position++];
         }
     
         @Override
         public void remove() {
     
         }
     }
     ```

     ```java
     public class InfoCollegeIterator implements Iterator<Department> {
         private List<Department> departments;
         private int position = 0;
     
         public InfoCollegeIterator(List<Department> departments) {
             this.departments = departments;
         }
     
         @Override
         public boolean hasNext() {
             return position < departments.size();
         }
     
         @Override
         public Department next() {
             return departments.get(position++);
         }
     
         @Override
         public void remove() {
             departments.remove(position);
         }
     }
     ```

   - 需要遍历的抽象类

     ```java
     public interface College {
         String getName();
         void addDepartment(String name, String desc);
         Iterator createIterator();
     }
     ```

   - 需要遍历的实现类

     ```java
     public class ComputerCollege implements College {
         private Department[] departments;
         private int size = 0;
     
         public ComputerCollege(int max) {
             this.departments = new Department[max];
         }
     
         @Override
         public String getName() {
             return "计算机学院";
         }
     
         @Override
         public void addDepartment(String name, String desc) {
             departments[size++] = new Department(name, desc);
         }
     
         @Override
         public Iterator createIterator() {
             return new ComputerCollegeIterator(departments);
         }
     }
     ```

     ```java
     public class InfoCollege implements College {
         private List<Department> departments;
         private int size = 0;
     
         public InfoCollege(int max) {
             departments = new ArrayList<>(max);
         }
     
         @Override
         public String getName() {
             return "信息学院";
         }
     
         @Override
         public void addDepartment(String name, String desc) {
             departments.add(new Department(name, desc));
             size++;
         }
     
         @Override
         public Iterator createIterator() {
             return new InfoCollegeIterator(departments);
         }
     }
     ```

3. 











