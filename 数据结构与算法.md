# 第一章 数据结构和算法概述

## 一，数据结构与算法的关系

1. 数据(data)结构(structure)是一门研究组织数据方式的学科，有了编程语言也就有了数据结构学好数据结构可以编写出更加漂亮，更加有效率的代码。
2. 要学习好数据结构就要多多考虑如何将生活中遇到的问题，用程序去实现解决
3. 程序=数据结构+算法
4. 数据结构是算法的基础，换言之，想要学好算法，需要把数据结构学到位。

## 二，线性结构和非线性结构

1. - 种不同的存储结构，即顺序存储结构和链式存储结构。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的
   - 链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息
   - 线性结构常见的有：数组、队列、链表和栈
2. 非线性结构
   - 非线性结构包括：二维数组，多维数组，广义表，树结构，图结构

# 第二章 稀疏数组和队列

## 一，稀疏sparsearray数组

1. 基本介绍

   当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。

2. 稀疏数组的处理方法是

   - 记录数组一共有几行几列，有多少个不同的值
   - 把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模

3. 应用实例

   ```java
   public class SparseArray {
       public static void main(String[] args) {
           //创建一个原始的二维数组
           //0表示没有棋子，1表示黑子，2表示白子
           int[][] chessArr = new int[11][11];
           chessArr[1][2] = 1;
           chessArr[2][3] = 2;
           System.out.println("初始数组-----------------------");
           for (int[] row : chessArr) {
               for (int val : row) {
                   System.out.print(val+ "\t");
               }
               System.out.println();
           }
   
           //将二维数组转为稀疏数组
           //1.先遍历二维数组，得到非0的数据个数
           int sum = 0;
           for (int[] row : chessArr) {
               for (int val : row) {
                   if (val != 0) sum++;
               }
           }
   
           //2.创建对应的稀疏数组
           int[][] sparseArr = new int[sum + 1][3];
           //3.给稀疏数组赋值
           sparseArr[0][0] = chessArr.length;
           sparseArr[0][1] = chessArr[0].length;
           sparseArr[0][2] = sum;
   
           //4.遍历二维数组，将非0的值存放到sparseArr中
           int count = 1;//用于记录是第几个非0数据
           for (int i = 0; i < chessArr.length; i++) {
               for (int j = 0; j < chessArr[i].length; j++) {
                   if (chessArr[i][j] != 0) {
                       sparseArr[count][0] = i;
                       sparseArr[count][1] = j;
                       sparseArr[count][2] = chessArr[i][j];
                       count++;
                   }
               }
           }
   
           System.out.println("稀疏数组为---------------------");
           for (int[] row : sparseArr) {
               for (int val : row) {
                   System.out.print(val + "\t");
               }
               System.out.println();
           }
   
           //将稀疏数组恢复成二维数组
           //1.根据稀疏数据的第一行数据创建二维数组
           int[][] chessArr2 = new int[sparseArr[0][0]][sparseArr[0][1]];
           //2.根据稀疏数组的后几行数据恢复原始数组数据
           for (int i = 1; i <= sparseArr[0][2]; i++) {
               chessArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];
           }
   
           System.out.println("恢复后的二维数组为------------------");
           for (int[] row : chessArr2) {
               for (int val : row) {
                   System.out.print(val + "\t");
               }
               System.out.println();
           }
       }
   }
   ```

## 二，队列

1. 队列的介绍

   - 队列是一个有序列表，可以用数组或是链表来实现。

   - 遵循先入先出的原则。即：先存木队列的数据，要先取出。后存入的要后取出

   - 示意图：（使用数组模拟队列示意图）

     ![](F:\截图\屏幕截图 2022-09-09 111825.png)

2. 数组模拟队列

   ```java
   //使用数组模拟队列，编写一个ArrayQueue类
   class ArrayQueue {
       private int maxSize;//表示数组的最大容量
       private int front;//队列头
       private int rear;//队列尾
       private int[] arr;//存放数据，模拟队列
   
       public ArrayQueue(int maxSize) {
           this.maxSize = maxSize;
           this.arr = new int[maxSize];
           this.front = -1;
           this.rear = -1;
       }
   
       //判断队列是否满
       public boolean isFull() {
           return rear == maxSize - 1;
       }
   
       //判断队列是否为空
       public boolean isEmpty() {
           return rear == front;
       }
   
       //添加数据到队列
       public void addQueue(int n) {
           if (isFull()) {
               System.out.println("队列已经满了");
               return;
           }
           rear++;
           arr[rear] = n;
       }
   
       //获取队列数据
       public int getQueue() {
           if (isEmpty()) {
               throw new RuntimeException("队列为空");
           }
           front++;
           return arr[front];
       }
   
       //显示队列的所有数据
       public void showQueue() {
           if (isEmpty()) {
               throw new RuntimeException("队列为空");
           }
           for (int i : arr) {
               System.out.print(i + "\t");
           }
       }
   }
   ```

3. 数组模拟环形队列

   - 尾索引的下一个为头索引时表示队列满，即将队列容量空出一个作为约定，这个在做判断队列满的时候需要注意(rear + 1) % maxSize == front为满

   - rear == front为空

   - ```java
     class CircleArrayQueue {
         private int maxSize;//表示数组的最大容量
         private int front;//队列头
         private int rear;//队列尾
         private int[] arr;//存放数据，模拟队列
     
         public CircleArrayQueue(int maxSize) {
             this.maxSize = maxSize;
             this.arr = new int[maxSize];
             //front指向队列的第一个元素
             this.front = 0;
             //rear指向队列的最后一个元素的后一个位置
             this.rear = 0;
         }
     
         //判断队列是否满
         public boolean isFull() {
             return (rear + 1) % maxSize == front;
         }
     
         //判断队列是否为空
         public boolean isEmpty() {
             return rear == front;
         }
     
         //添加数据到队列
         public void addQueue(int n) {
             if (isFull()) {
                 System.out.println("队列已经满了");
                 return;
             }
             arr[rear] = n;
             rear = (rear + 1) % maxSize;
         }
     
         //获取队列数据
         public int getQueue() {
             if (isEmpty()) {
                 throw new RuntimeException("队列为空");
             }
             int value = arr[front];
             front = (front + 1) % maxSize;
             return value;
         }
     
         //显示队列的所有数据
         public void showQueue() {
             if (isEmpty()) {
                 throw new RuntimeException("队列为空");
             }
             for (int i = front; i < front + size(); i++) {
                 System.out.printf("arr[%d]=%d\n", i % maxSize, arr[i % maxSize]);
             }
         }
     
         //求出当前队列有效数据的个数
         public int size() {
             return (rear - front + maxSize) % maxSize;
         }
     }
     ```

# 第三章 链表

## 一，单向链表

1. 介绍

   - 链表是以节点的方式来存储
   - 每个节点包含data域，next域：指向下一个节点
   - 链表的各个节点不一定是连续存储
   - 链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定

2. 单向链表的创建和遍历案例

   ```java
   //定义SingleLinkedList管理HeroNode
   class SingleLinkedList {
       //初始化一个头节点
       private HeroNode head = new HeroNode();
   
       //添加节点
       //1. 找到当前链表的最后的节点
       //2. 将最后节点的next指向新的节点
       public void add(HeroNode heroNode) {
           //遍历链表，找出最后一个节点
           HeroNode temp = head;
           for (;;) {
               if (temp.next == null) break;
               temp = temp.next;
           }
           //将新的节点赋给最后节点的next
           temp.next = heroNode;
       }
   
       //显示遍历链表
       public void list() {
           //判断链表是否为空
           if (head.next == null) {
               System.out.println("链表为空");
               return;
           }
           HeroNode temp = head.next;
           for (;;) {
               System.out.println(temp);
               if (temp.next == null) break;
               temp = temp.next;
           }
       }
   }
   //定义HeroNode，每一个HeroNode对象就是一个节点
   class HeroNode {
       private int no;
       private String name;
       private String nickName;
       HeroNode next;
   
       public HeroNode() {
       }
   
       public HeroNode(int no, String name, String nickName) {
           this.no = no;
           this.name = name;
           this.nickName = nickName;
       }
   
       @Override
       public String toString() {
           return "HeroNode{" +
                   "no=" + no +
                   ", name='" + name + '\'' +
                   ", nickName='" + nickName + '\'' +
                   '}';
       }
   }
   ```

3. 单向链表按顺序插入节点

   ```java
   //按顺序插入节点
   public void addByOrder(HeroNode heroNode) {
       HeroNode temp = head;
       for (;;) {
           if (temp.next == null) {
               //temp已经是最后一个节点了，直接将新节点插入到尾部
               temp.next = heroNode;
               break;
           }
           if (temp.next.no > heroNode.no) {
               //将新节点插入到temp之后
               heroNode.next = temp.next;
               temp.next = heroNode;
               break;
           }
           if (temp.next.no == heroNode.no) {
               //说明新节点已经存在
               System.out.println(heroNode.no + "号节点已经存在");
               break;
           }
           //temp后移
           temp = temp.next;
       }
   }
   ```

4. 修改节点

   ```java
   //修改节点
   public void update(HeroNode newNode) {
       if (head.next == null) {
           System.out.println("链表为空");
           return;
       }
       HeroNode temp = this.head;
       for (;;) {
           if (temp.next == null || newNode.no == 0) {
               //遍历完了所有节点都没有找到
               System.out.println("修改失败，未找到节点");
               break;
           }
           if (temp.no == newNode.no) {
               //找到了，修改节点
               temp.name = newNode.name;
               temp.nickName = newNode.nickName;
               break;
           }
           temp = temp.next;
       }
   }
   ```

5. 删除节点

   ```java
   //删除节点
   public void delete(int no) {
       if (head.next == null) {
           System.out.println("链表为空");
           return;
       }
       HeroNode temp = this.head;
       for (;;) {
           if (temp.next == null) {
               //遍历完了所有节点都没有找到
               System.out.println("删除失败，未找到节点");
               break;
           }
           if (temp.next.no == no) {
               //找到了，删除节点
               temp.next = temp.next.next;
               break;
           }
           temp = temp.next;
       }
   }
   ```

6. 查找单链表中倒数第index个节点

   ```java
   public HeroNode reciprocal(int index) {
       if (head.next == null) return null;
       int size = getSize();
       if (index < 0 || index > size) return null;
       HeroNode temp = this.head.next;
       for (int i = 0; i < size - index; i++) {
           temp = temp.next;
       }
       return temp;
   }
   
   public int getSize() {
       if (head.next == null) return 0;
       HeroNode temp = head.next;
       int size = 1;
       for (;;) {
           if (temp.next == null) break;
           temp = temp.next;
           size++;
       }
       return size;
   }
   ```

7. 单链表的反转

   ```java
   //单链表的反转
   public void reverse() {
       if (head.next == null || head.next.next == null) return;
       HeroNode temp = this.head.next;
       HeroNode reverseHead = new HeroNode();
       HeroNode tempNext;
       for (;;) {
           tempNext = temp.next;
           temp.next = reverseHead.next;
           reverseHead.next = temp;
           if (tempNext == null) break;
           temp = tempNext;
       }
       head.next = reverseHead.next;
   }
   ```

8. 从尾到头打印单链表

   ```java
   public void reversePrint() {
       if (head.next == null) return;
       Stack<HeroNode> stack = new Stack<>();
       HeroNode temp = this.head.next;
       while (temp != null) {
           stack.push(temp);
           temp = temp.next;
       }
       while (stack.size() > 0) {
           System.out.println(stack.pop());
       }
   }
   ```

9. 合并两个有序的单链表，合并之后依旧有序

   ```java
   public static SingleLinkedList merge(SingleLinkedList... singleLinkedLists) {
       SingleLinkedList singleLinkedList = singleLinkedLists[0];
       for (int i = 1; i < singleLinkedLists.length; i++) {
           SingleLinkedList tempList = singleLinkedLists[i];
           HeroNode temp = tempList.head.next;
           while (temp != null) {
               HeroNode tempNode = new HeroNode(temp.no, temp.name, temp.nickName);
               singleLinkedList.addByOrder(tempNode);
               temp = temp.next;
           }
       }
       return singleLinkedList;
   }
   ```

## 二，双向链表

1. 增删改查

   ```java
   //定义DoubleLinkedList管理Node
   class DoubleLinkedList {
       //初始化一个头节点
       private Node head = new Node();
   
       //遍历
       public void list() {
           if (head.next == null) {
               System.out.println("链表为空");
               return;
           }
           Node temp = head.next;
           for (;;) {
               if (temp == null) {
                   break;
               }
               System.out.println(temp);
               temp = temp.next;
           }
       }
   
       //添加
       public void add(Node node) {
           Node temp = this.head;
           for (;;) {
               if (temp.next == null) {
                   break;
               }
               temp = temp.next;
           }
           temp.next = node;
           node.prev = temp;
       }
   
       //修改
       public void update(Node newNode) {
           if (head.next == null) {
               System.out.println("链表为空");
               return;
           }
           Node temp = this.head.next;
           for (;;) {
               if (temp == null) {
                   System.out.println("未找到编号为" + temp.no + "的节点");
                   break;
               }
               if (temp.no == newNode.no) {
                   temp.name = newNode.name;
                   break;
               }
               temp = temp.next;
           }
       }
   
       //删除
       public void delete(int no) {
           if (head.next == null) {
               System.out.println("链表为空");
               return;
           }
           Node temp = this.head.next;
           for (;;) {
               if (temp == null) {
                   System.out.println("未找到编号为" + temp.no + "的节点");
                   break;
               }
               if (temp.no == no) {
                   temp.prev.next = temp.next;
                   if (temp.next != null) {
                       temp.next.prev = temp.prev;
                   }
                   break;
               }
               temp = temp.next;
           }
       }
   }
   //定义Node，每一个Node对象就是一个节点
   class Node {
       int no;
       String name;
       Node next;
       Node prev;
   
       public Node() {
       }
   
       public Node(int no, String name) {
           this.no = no;
           this.name = name;
       }
   
       @Override
       public String toString() {
           return "Node{" +
                   "no=" + no +
                   ", name='" + name + '\'' +
                   '}';
       }
   }
   ```

2. 按编号顺序添加

   ```java
   //按编号顺序添加
   public void addByOrder(Node node) {
       Node temp = this.head;
       for (;;) {
           if (temp.next == null) {
               temp.next = node;
               node.prev = temp;
               break;
           }
           if (temp.next.no > node.no) {
               temp.next.prev = node;
               node.next = temp.next;
               temp.next = node;
               node.prev = temp;
               break;
           }
           temp = temp.next;
       }
   }
   ```

## 三，单向环形列表

1. Josephu问题

   设编号为1，2，n的n个人围坐一圈，约定编号为k(1<=k<=n)的人从1开始报数，数到m的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出队编号的序列。

2. 构建和遍历

   ```java
   //创建一个环形的单向链表
   class SingleRingLinkedList {
       //创建一个first节点
       private RingNode first;
   
       //初始化
       public void init(int nums) {
           if (nums < 1) {
               System.out.println("nums值不正确");
           }
           RingNode curNode = null;
           for (int i = 1; i <= nums; i++) {
               RingNode node = new RingNode(i);
               if (i == 1) {
                   first = node;
                   first.setNext(first);
                   curNode = first;
               } else {
                   curNode.setNext(node);
                   node.setNext(first);
                   curNode = node;
               }
           }
       }
   
       //遍历
       public void list() {
           if (first == null) {
               System.out.println("链表为空");
               return;
           }
           RingNode curNode = first;
           for (;;) {
               System.out.println(curNode);
               if (curNode.getNext() == first) {
                   break;
               }
               curNode = curNode.getNext();
           }
       }
   }
   //节点
   @Data
   @NoArgsConstructor
   class RingNode {
       private int no;
       private RingNode next;
   
       public RingNode(int no) {
           this.no = no;
       }
   
       @Override
       public String toString() {
           return "RingNode{" +
                   "no=" + no +
                   '}';
       }
   }
   ```

3. Josephu问题案例

   ```java
   /**
    * 解决Josephu问题
    * @param startNo 开始报数的编号
    * @param countNum 每次数多少次才出列
    * @param nums 最初共有多少人
    */
   public void josephu(int startNo, int countNum, int nums) {
       //校验参数
       if (startNo < 1 || startNo > nums || countNum < 1) {
           System.out.println("参数有误");
           return;
       }
       //初始化
       init(nums);
       //创建辅助指针
       RingNode helper = first;
       //让辅助指针指向环形链表的最后节点
       for (;;) {
           if (helper.getNext() == first) {
               break;
           }
           helper = helper.getNext();
       }
       //开始报数前，让first和helper移动startNo - 1次
       for (int i = 0; i < startNo - 1; i++) {
           first = first.getNext();
           helper = helper.getNext();
       }
       //开始报数
       for (;;) {
           if (helper == first) {//说明圈中只有一个节点
               System.out.println(first.getNo());
               break;
           }
           //让first和helper同时移动countNum - 1
           for (int i = 0; i < countNum - 1; i++) {
               first = first.getNext();
               helper = helper.getNext();
           }
           //移除first，表示出圈
           System.out.println(first.getNo());
           first = first.getNext();
           helper.setNext(first);
       }
   }
   ```

# 第四章 栈

## 一，栈的介绍

1. 简介

   - 栈的英文为(stack)

   - 栈是一个先入后出(FILO-First In Last Out)的有序列表。

   - 栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。

   - 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除

2. 应用场景

   - 子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。
   - 处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。
   - 表达式的转换[中缀表达式转后缀表达式]与求值（实际解决）。
   - 二叉树的遍历。
   - 图形的深度优先(depth一first)搜索法。

## 二，数组模拟栈实现

```java
class ArrayStack {
    private int maxSize;//栈的大小
    private int[] stack;//数据存放在该数组
    private int top = -1;//栈顶，初始化为-1

    //构造器
    public ArrayStack(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[maxSize];
    }

    //判断栈满
    public boolean isFull() {
        return top == maxSize - 1;
    }

    //判断栈空
    public boolean isEmpty() {
        return top == -1;
    }

    //入栈
    public void push(int value) {
        if (isFull()) {
            throw new RuntimeException("栈满");
        }
        top++;
        stack[top] = value;
    }

    //出栈
    public int pop() {
        if (isEmpty()) {
            throw new RuntimeException("栈空");
        }
        int value = stack[top];
        top--;
        return value;
    }

    //遍历
    public void list() {
        if (isEmpty()) {
            System.out.println("栈空");
            return;
        }
        for (int i = top; i >= 0; i--) {
            System.out.printf("stack[%d]=%d\n", i, stack[i]);
        }
    }
}
```

## 三，栈实现计算器

```java
public class Calculator {
    public static void main(String[] args) {
        String expression = "300+2*6-2";
        //数值栈
        ArrStack numStack = new ArrStack(10);
        //操作符栈
        ArrStack operStack = new ArrStack(10);
        int index = 0;
        int num1 = 0;
        int num2 = 0;
        int operator = 0;
        int result = 0;
        char ch = ' ';
        String keepNum = "";
        //循环取出expression的每一个字符
        while (index < expression.length()) {
            ch = expression.charAt(index);
            //判断是否为操作符
            if (operStack.isOperator(ch)) {
                //判断操作符栈是否为空
                if (!operStack.isEmpty()) {
                    //判断当前的操作符优先级是否比栈顶的优先级高
                    if (operStack.priority(ch) <= operStack.priority(operStack.peek())) {
                        //当前操作符优先级低，需要从数字栈中pop出两个数和符号栈中pop出一个数，进行运算
                        num1 = numStack.pop();
                        num2 = numStack.pop();
                        operator = operStack.pop();
                        result = operStack.cal(num1, num2, operator);
                        //把计算结果和当前的运算符入栈
                        numStack.push(result);
                        operStack.push(ch);
                    } else {
                        //当前操作符优先级高，直接入栈
                        operStack.push(ch);
                    }
                } else {
                    //当前操作符栈为空，直接入栈
                    operStack.push(ch);
                }
            } else {
                //为数字，判断后面的是否为数字，如果是数字，再次循环，拼接
                keepNum += ch;
                if (index + 1 >= expression.length() || operStack.isOperator(expression.charAt(index + 1))) {
                    //后一位为操作符或者已经是表达式最后一位数,keepNum入栈
                    numStack.push(Integer.parseInt(keepNum));
                    keepNum = "";
                }
            }
            index++;
        }
        //最终计算
        while (!operStack.isEmpty()) {
            num1 = numStack.pop();
            num2 = numStack.pop();
            operator = operStack.pop();
            result = operStack.cal(num1, num2, operator);
            numStack.push(result);
        }
        System.out.println(numStack.pop());
    }
}
class ArrStack {
    private int maxSize;//栈的大小
    private int[] stack;//数据存放在该数组
    private int top = -1;//栈顶，初始化为-1

    //构造器
    public ArrStack(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[maxSize];
    }

    //判断栈满
    public boolean isFull() {
        return top == maxSize - 1;
    }

    //判断栈空
    public boolean isEmpty() {
        return top == -1;
    }

    //入栈
    public void push(int value) {
        if (isFull()) {
            throw new RuntimeException("栈满");
        }
        top++;
        stack[top] = value;
    }

    //出栈
    public int pop() {
        if (isEmpty()) {
            throw new RuntimeException("栈空");
        }
        int value = stack[top];
        top--;
        return value;
    }

    //返回当前栈顶的值，但是不出栈
    public int peek() {
        return stack[top];
    }

    //遍历
    public void list() {
        if (isEmpty()) {
            System.out.println("栈空");
            return;
        }
        for (int i = top; i >= 0; i--) {
            System.out.printf("stack[%d]=%d\n", i, stack[i]);
        }
    }

    //返回运算符的优先级，数字越大优先级越高
    public int priority(int operator) {
        if (operator == '+' || operator == '-') return 0;
        else if (operator == '*' || operator == '/') return 1;
        else return -1;
    }

    //判断是不是一个运算符
    public boolean isOperator(char val) {
        return val == '+' || val == '-' || val == '*' || val == '/';
    }

    //计算
    public int cal(int num1, int num2, int operator) {
        int result = 0;
        switch (operator) {
            case '+':
                result = num2 + num1;
                break;
            case '-':
                result = num2 - num1;
                break;
            case '*':
                result = num2 * num1;
                break;
            case '/':
                result = num2 / num1;
                break;
        }
        return result;
    }
}
```

## 四，前缀、中缀、后缀表达式（逆波兰表达式）

1. 前缀表达式（波兰表达式）

   - 前缀表达式又称波兰式，前缀表达式的运算符位于操作数之前
   - (3+4)×5-6对应的前缀表达式就是-×+3456

2. 前缀表达式的计算机求值

   从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素和次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果

   例如：(3+4)×5-6对应的前缀表达式就是-×+3456，针对前缀表达式求值步骤如下：

   - 从右至左扫描，将6、5、4、3压入堆栈
   - 遇到+运算符，因此弹出3和4(3为栈顶元素，4为次顶元素)，计算出3+4的值，得7，再将7入栈
   - 接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈
   - 最后是-运算符，计算出35-6的值，即29，由此得出最终结果

3. 中缀表达式

   - 中缀表达式就是常见的运算表达式，如(3+4)×5-6
   - 中缀表达式的求值是我们人最熟悉的，但是对计算机来说却不好操作（前面的案例就能看的这个问题)，因此，在计算结果时，往往会将中缀表达式转成其它表达式来操作(一般转成后缀表达式)

4. 后缀表达式（逆波兰表达式）

   - 后缀表达式又称逆波兰表达式，与前缀表达式相似，只是运算符位于操作数之后
   - (3+4)×5-6对应的后缀表达式就是34+5×6-

5. 后缀表达式的计算机求值

   从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素和栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果

   例如：(3+4)×5-6对应的前缀表达式就是34+5×6-，针对后缀表达式求值步骤如下：

   - 从左至右扫描，将3和4压入堆栈
   - 遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素)，计算出3+4的值，得7，再将7入栈
   - 将5入栈；
   - 接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈
   - 将6入栈；
   - 最后是-运算符，计算出35-6的值，即29，由此得出最终结果

6. 逆波兰表达式案例

   ```java
   public static String calculate(String postfixExpression) {
       //将suffixExpression放入到ArrayList中
       String[] split = postfixExpression.split(" ");
       List<String> rpnList = Arrays.asList(split);
       //创建栈
       Stack<String> stack = new Stack<>();
       //遍历rpnList
       for (String str : rpnList) {
           if (str.matches("\\d+")) {
               stack.push(str);
           } else {
               int num1 = Integer.parseInt(stack.pop());
               int num2 = Integer.parseInt(stack.pop());
               int result;
               switch (str) {
                   case "+":
                       result = num2 + num1;
                       break;
                   case "-":
                       result = num2 - num1;
                       break;
                   case "*":
                       result = num2 * num1;
                       break;
                   case "/":
                       result = num2 / num1;
                       break;
                   default :
                       throw new RuntimeException("运算符有误");
               }
               stack.push(result + "");
           }
       }
       return stack.pop();
   }
   ```

###  中缀表达式转换为后缀表达式

1. 初始化两个栈：运算符s1和储存中间结果的栈s2
2. 从左至右扫描中缀表达式
3. 遇到操作数时，将其压s2
4. 遇到运算符时，比较其与s1栈顶运算符的优先级：
   - 如果s1为空，或栈顶运算符为左括号"("，则直接将此运算符入栈
   - 否则，若优先级比栈顶运算符的高，也将运算符压入s1
   - 否则，将s1栈顶的运算符弹出并压入到s2中，再次转到4.1与s1中新的栈顶运算符相比较
5. 遇到括号时：
   - 如果是左括号"("，直接压入s1
   - 如果是右括号")"，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃
6. 重复步骤2至5，直到表达式的最右边
7. 将s1中剩余的运算符依次弹出并压入s2
8. 依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式

**代码实现**

```java
public static String infixToPostfix(String infixExpression) {
    ArrayList<String> list = new ArrayList<>();
    int index = 0;//指针，用于遍历中缀表达式
    String keepNum = "";//用于多位数的拼接
    char ch;
    while (index < infixExpression.length()) {
        ch = infixExpression.charAt(index);
        //判断ch是否为数字
        if  (ch < 48 || ch > 57) {
            //ch为非数字，直接加入到list中
            list.add(ch + "");
        } else {
            //非数字，需要考虑多位数，和最后一位数
            keepNum += ch;
            if (index + 1 >= infixExpression.length() || infixExpression.charAt(index + 1) < 48 || infixExpression.charAt(index + 1) > 57) {
                list.add(keepNum);
                keepNum = "";
            }
        }
        index++;
    }
    //将中缀表达式转为后缀表达式
    Stack<String> s1 = new Stack<>();//符号栈
    StringBuilder s2 = new StringBuilder();//用于存储中间结果
    HashMap<String, Integer> map = new HashMap<>();//用于比较运算符的优先级
    map.put("+", 1);
    map.put("-", 1);
    map.put("*", 2);
    map.put("/", 2);
    map.put("(", 0);
    map.put(")", 0);
    for (String s : list) {
        if (s.matches("\\d+")) {
            //如果是一个数，直接拼接
            s2.append(s + " ");
        } else if (s.equals("(")) {
            //如果是一个左括号，直接入栈
            s1.push(s);
        } else if (s.equals(")")) {
            //如果是一个右括号，依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止
            while (!s1.peek().equals("(")) {
                s2.append(s1.pop() + " ");
            }
            //最后的左括号也要弹出
            s1.pop();
        } else {
            //是一个运算符，非“（”“）”
            while (!s1.isEmpty() && map.get(s) <= map.get(s1.peek())) {
                //s1不为空，且优先级小于s1栈顶的运算符，拼接到s2
                s2.append(s1.pop() + " ");
            }
            //如果s1为空，或者优先级比s1栈顶运算符的高，压入s1
            s1.push(s);
        }
    }
    while (!s1.isEmpty()) {
        s2.append(s1.pop() + " ");
    }
    return s2.toString();
}
```

# 第五章 递归

## 一，递归规则

1. 执行一个方法时，就创建一个新的受保护的独立空间（栈空间）
2. 方法的局部变量是独立的，不会相互影响
3. 如果方法中使用的是引用类型的变量，就会共享该引用类型的数据
4. 递归必须向退出递归的条件逼近，否则就是无限递归
5. 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。

## 二，迷宫问题

```java
/**
 * 使用递归回溯寻找迷宫出路
 * @param maze 地图
 * @param i, j 表示出发的位置
 * @return 找到出路返回true，否则返回false
 *
 * 小球到达maze[6][5]表示到达终点
 * 0表示没有走过，1表示墙，2表示可以走，3表示走过但是走不通
 * 按照下-右-上-左的顺序找路
 */
public static boolean findWay(int[][] maze, int i, int j) {
    if (maze[6][5] == 2) {
        return true;
    } else {
        //maze[i][j] == 0表示该点还没有走过
        if (maze[i][j] == 0) {
            //将该点设置为2，表示走过
            maze[i][j] = 2;
            if (findWay(maze, i + 1, j)) return true;//向下
            else if (findWay(maze, i, j + 1)) return true;//向右
            else if (findWay(maze, i - 1, j)) return true;//向上
            else if (findWay(maze, i, j - 1)) return true;//向左
            else {
                //上下左右都走不通，将该点设置为死路
                maze[i][j] = 3;
                return false;
            }
        } else {
            //该点已经走过，或者是墙
            return false;
        }
    }
}
```

## 三，八皇后问题

```java
public class EightQueens {
    static int count = 0;

    public static void main(String[] args) {
        //用一个以为数组表示皇后的位置，数组的下标加一表示第几个皇后
        int[] arr = new int[8];
        check(0, arr);
        System.out.println(count);//92
    }

    /**
     * 放置皇后
     * @param n 当前摆放的是第几个皇后
     * @param arr
     */
    public static void check(int n, int[] arr) {
        if (n == 8) {
            //当n == 8时，说明已经放置了8个皇后，打印出一次结果
            for (int i = 0; i < arr.length; i++) {
                System.out.printf("%d ", arr[i]);
            }
            System.out.println();
            count++;
            return;
        }
        for (int i = 0; i < 8; i++) {
            //把当前皇后放到第i个位置
            arr[n] = i;
            //判断是否冲突
            if (judgmentConflict(n, arr)) {
                //不冲突，接着放第n + 1个皇后
                check(n + 1, arr);
            }
            //如果冲突，把当前皇后放到第i + 1个位置，即继续循环
        }
    }

    /**
     * 判断是否冲突
     * @param n 当前摆放的是第几个皇后
     * @return
     */
    public static boolean judgmentConflict(int n, int[] arr) {
        for (int i = 0; i < n; i++) {
            //arr[i] == arr[n]：表示在同一列
            //Math.abs(n - i) == Math.abs(arr[n] - arr[i])：表示在同一斜线
            if (arr[i] == arr[n] || Math.abs(n - i) == Math.abs(arr[n] - arr[i])) {
                return false;
            }
        }
        return true;
    }
}
```

# 第六章 排序

## 一，排序算法的介绍与分类

1. 排序算法的介绍

   排序也称排序算法(Sort Algorithm)，排序是将组数据，依指定的顺序进行排列的过程。

2. 排序的分类

   - 内部排序

     指将需要处理的所有数据都加载到内部存储器中进行排序。

   - 外部排序

     数据量过大，无法全部加戟到内存中，需要借助外部存储进行排序。

3. 常见的排序算法分类

   ![](F:\截图\屏幕截图 2022-09-14 201526.png)

## 二，算法的时间复杂度

1. 度量一个程序执行时间的两种方法

   - 事后统计的方法

     这种方法可行，但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素，这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快

   - 事前估算的方法

     通过分析某个算法的时间复杂度来判断哪个算法更优

2. 时间频度

   一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。

3. 时间复杂度

   - 一般情况下，算法中的基本操作语句的重复执行次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数fn)，使得当n趋近于无穷大时，Tn)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称O(f(n))为算法的渐进时间复杂度，简称时间复杂度。
   - T(n)不同，但时间复杂度可能相同。如：$T(n)=n^2+7n+6$与$T(n)=3n^2+2n+2$它们的T(n)不同，但时间复杂度相同，都为$O(n^2)$。
   - 计算时间复杂度的方法：
     - 用常数1代替运行时间中的所有加法常数
     - 修改后的运行次数函数中，只保留最高阶项
     - 去除最高阶项的系数

4. 常见的时间复杂度

   - 常数阶$O(1)$

     无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就是$O(1)$

   - 对数阶$O(log_2n)$

     ```java
     int i = 1;
     while (i < n) {
         i = i * 2;
     }
     ```

     在while循环里面，每次都将i乘以2，乘完之后i距离n就越来越近。

     假设循环x次之后i就大于n了，此时退出循环。也就是2的x次方等于n，即2^x^=n。取对数之后x=log~2~n，也就是说代码循环执行了log~2~n次，因此这个代码的时间复杂度为$O(log_2n)$

   - 线性阶$O(n)$

     ```java
     for (i = 0;i < n;i++) {
         ...
     }
     ```

     代码循环执行了n次，因此这段代码的时间复杂度为$O(n)$

   - 线性对数阶$O(nlog_2n)$

     ```java
     for (i = 0;i < n;i++) {
         int j = 1;
         while (j < n) {
             j = j * 2;
         }
     }
     ```

     线性对数阶$O(nlog_2n)$就是将时间复杂度为$O(log_2n)$的代码再循环n次，这样它的时间复杂度就是$nO(log_2n)$，也就是$O(nlog_2n)$

   - 平方阶$O(n^2)$

     ```java
     for (i = 0;i < n;i++) {
         for (i = 0;i < n;i++) {
             ...
         }
     }
     ```

     平方阶$O(n^2)$其实就是嵌套了两层n的循环，时间复杂度为$O(n*n)$，如果其中一层循环的n改为m，那么时间复杂度就是$O(n*m)$。

   - 立方阶$O(n^3)$

   - k次方阶$O(n^k)$

   - 指数阶$O(2^n)$

5. 平均时间复杂度和最坏时间复杂度

   - 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间
   - 最坏情况下的时间复杂度称最坏时间复杂度。**一般讨论的时间复杂度均是最坏情况下的时间复杂度。**这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长
   - 平均时间复杂度和最坏时间复杂度是否一致和算法有关

6. 空间复杂度

   - 类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模n的函数。
   - 空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模有关，它随着n的增大而增大，当n较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况
   - **在做算法分析时，主要讨论的是时间复杂度。**从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis，memcache)和算法（基数排序）本质就是用空间换时间

## 三，冒泡排序

1. 基本介绍

   冒泡排序(Bubble Sorting)的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。

2. 冒泡排序的优化

   ```java
   public static void sort(int[] arr) {
       int temp = 0;
       //标志变量，判断是否进行过交换
       boolean flag = false;
       for (int i = 0; i < arr.length - 1; i++) {
           for (int j = 0; j < arr.length - 1 - i; j++) {
               if (arr[j] > arr[j + 1]) {
                   //进行过交换，将flag设置为true
                   flag = true;
                   temp = arr[j];
                   arr[j] = arr[j + 1];
                   arr[j + 1] = temp;
               }
           }
           if (flag) {
               flag = false;
           } else {
               //如果没有进行过交换，说明数组已经有序，直接break
               break;
           }
       }
   }
   ```

## 四，选择排序

1. 基本介绍

    选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置眉达到排序的目的。

2. 基本思想

   选择排序(select sorting)也是一种简单的排序方法。它的基本思想是：第一次从arr[0]\~arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]\~arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]\~arr[n-1]中选取最小值，与arr[2]交换，…，第i次从arr[i-1]\~arr[n-1]中选取最小值，与arr[i-1]交换，…，第n-1次从arr[n-2]\~arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列

3. 代码实现

   ```java
   public static void sort(int[] arr) {
       int minIndex;
       int min;
       for (int i = 0; i < arr.length - 1; i++) {
           min = arr[i];
           minIndex = i;
           for (int j = i; j < arr.length; j++) {
               if (min > arr[j]) {
                   minIndex = j;
                   min = arr[j];
               }
           }
           if (minIndex != i) {
               arr[minIndex] = arr[i];
               arr[i] = min;
           }
       }
   }
   ```

## 五，插入排序

1. 基本介绍

   插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。

2. 基本思想

   插入排序(Insertion Sorting)的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。

3. 代码实现

   ```java
   public static void sort(int[] arr) {
       int insertVal;
       int insertIndex;
       for (int i = 1; i < arr.length; i++) {
           //当前需要插入的值
           insertVal = arr[i];
           for (insertIndex = i - 1; insertIndex >= 0; insertIndex--) {
               //如果当前需要插入的值小于arr[insertIndex]就将arr[insertIndex]后移
               if (insertVal < arr[insertIndex]) {
                   arr[insertIndex + 1] = arr[insertIndex];
               } else {
                   //如果当前插入的值大于arr[insertIndex]，直接break
                   break;
               }
           }
           //将insertVal插入到insertIndex + 1的位置
           arr[insertIndex + 1] = insertVal;
       }
   }
   ```

## 六，希尔排序

1. 基本介绍

   希尔排序(Shell Sorting)也是一种插入排序，他是简单插入排序经过改进之后的一个更高效的版本，也称为**缩小增量排序**

2. 基本思想

   希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序。随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止

3. 代码实现（交换法）

   ```java
   public static void sortExchange(int[] arr) {
       int temp;
       for (int gap = arr.length / 2; gap > 0; gap /= 2) {
           for (int i = gap; i < arr.length; i++) {
               for (int j = i - gap; j >= 0; j -= gap) {
                   if (arr[j] > arr[j + gap]) {
                       temp = arr[j];
                       arr[j] = arr[j + gap];
                       arr[j + gap] = temp;
                   }
               }
           }
       }
   }
   ```

4. 代码实现（移位法）

   ```java
   public static void sortOffset(int[] arr) {
       int insertVal;
       int insertIndex;
       for (int gap = arr.length / 2; gap > 0; gap /= 2) {
           for (int i = gap; i < arr.length; i++) {
               insertVal = arr[i];
               for (insertIndex = i - gap; insertIndex >= 0; insertIndex -= gap) {
                   if (insertVal < arr[insertIndex]) {
                       arr[insertIndex + gap] = arr[insertIndex];
                   } else {
                       break;
                   }
               }
               arr[insertIndex + gap] = insertVal;
           }
       }
   }
   ```

## 七，快速排序

1. 基本介绍

   快速排序(Quick Sort)是对冒泡排序的一种改进。

2. 基本思想

   通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序例

3. 代码实现

   ```java
   public static void sort(int[] arr, int left, int right) {
       int l = left;
       int r = right;
       int pivot = arr[(l + r) / 2];//pivot为中轴值
       int temp;
       while (l < r) {
           //在左边寻找一个大于等于pivot的值
           while (arr[l] < pivot) l++;
           //在右边寻找一个小于等于pivot的值
           while (arr[r] > pivot) r--;
           //如果l大于等于了r说明pivot左边全是小于等于pivot，右边全是大于等于pivot，直接break
           if (l >= r) break;
           //找到之后交换
           temp = arr[r];
           arr[r] = arr[l];
           arr[l] = temp;
           if (arr[l] == pivot) r--;
           if (arr[r] == pivot) l++;
       }
       if (l == r) {
           l++;
           r--;
       }
       if (left < r) {
           sort(arr, left, r);
       }
       if (right > l) {
           sort(arr, l, right);
       }
   }
   ```

## 八，归并排序

1. 基本介绍

   归并排序(Merge Sort)是利用归并的思想实现的排序方法，该算法采用经典的分治(divide-and-conquer)策略（分治法将间题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案"修补“在起，即分而治之)。

2. 代码实现

   ```java
   public static void divide(int[] arr, int left, int right, int[] temp) {
       if (left < right) {
           int mid = (left + right) / 2;
           divide(arr, left, mid, temp);
           divide(arr, mid + 1, right, temp);
           sort(arr, left, mid, right, temp);
       }
   }
   
   /**
    *
    * @param arr 需要排序的原始数组
    * @param left 左边有序序列的初始索引
    * @param mid 中间索引
    * @param right 右边有序序列的初始索引
    * @param temp 中转的数组
    */
   public static void sort(int[] arr, int left, int mid, int right, int[] temp) {
       int i = left;//左指针
       int j = mid + 1;//右指针
       int t = 0;//中转数组temp的下标指针
   
       //把左右两边的有序数组按照顺序放入到temp中
       while (i <= mid && j <= right) {
           if (arr[i] < arr[j]) {
               //将arr[i]放入到temp中，i，t后移
               temp[t] = arr[i];
               i++;
               t++;
           } else {
               //将arr[i]放入到temp中，j，t后移
               temp[t] = arr[j];
               j++;
               t++;
           }
       }
   
       //把另一边剩余的数据全部放入到temp，两边都有可能剩余数据
       while (i <= mid) {
           temp[t] = arr[i];
           i++;
           t++;
       }
       while (j <= right) {
           temp[t] = arr[j];
           j++;
           t++;
       }
   
       //将temp中的数据复制到原始数组arr中
       t = 0;
       for (int k = left; k <= right; k++) {
           arr[k] = temp[t];
           t++;
       }
   }
   ```

## 九，基数排序

1. 基本介绍

   - 基数排序(radix sort)属于“分配式排序”(distribution sort)，又称“桶子法”(bucket sort)或bin sort，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用
   - 基数排序法是属于稳定性的排序，基数排序法的是效率高的稳定性排序法
   - 基数排序(Radix Sort)是桶排序的扩展
   - 基数排序是1887年赫尔曼·何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较。

2. 基本思想

   将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。

3. 代码实现

   ```java
   public static void sort(int[] arr) {
       //创建桶和桶的数据下标数组
       int[][] bucket = new int[10][arr.length];
       int[] bucketIndex = new int[10];
   
       //找出数组中的最大值，并求出最大值的长度
       int max = arr[0];
       for (int i = 1; i < arr.length; i++) {
           if (arr[i] > arr[0]) max = arr[i];
       }
       int maxLength = (max + "").length();
   
       //循环maxLength次
       for (int i = 0; i < maxLength; i++) {
           //按照每次的个，十，百。。。为放入数据
           for (int j = 0; j < arr.length; j++) {
               int digit = (int) (arr[j] / Math.pow(10, i) % 10);
               bucket[digit][bucketIndex[digit]] = arr[j];
               bucketIndex[digit]++;
           }
           //按照桶的顺序取出数据
           int index = 0;
           for (int j = 0; j < bucketIndex.length; j++) {
               if (bucketIndex[j] != 0) {
                   for (int k = 0; k < bucketIndex[j]; k++) {
                       arr[index++] = bucket[j][k];
                   }
                   bucketIndex[j] = 0;
               }
           }
       }
   }
   ```

## 十，常用的排序算法总结和对比

1. 相关术语解释

   - 稳定：如果a原本在b前面，而a==b，排序之后a任然在b的前面
   - 不稳定：如果a原本在b的前面，而a==b，排序之后a可能会出现在b的后面
   - 内排序：所有排序操作都是在内存中完成
   - 外排序：由于数据过大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行
   - 时间复杂度：一个算法执行所耗费的时间
   - 空间复杂度：运行完一个程序所需要的内存大小
   - n：数据规模
   - k：桶的个数
   - In-place：不占用额外内存
   - Out-place：占用额外内存

2. 常用的排序算法对比

   ![](F:\截图\屏幕截图 2022-09-16 150239.png)

# 第七章 查找

## 一，二分查找

1. 代码实现

   ```java
   public static int search(int[] arr, int val, int left, int right) {
       if (left > right) {
           return -1;
       }
       int mid = (left + right) / 2;
       if (arr[mid] > val) {
           return search(arr, val, left, mid - 1);
       } else if (arr[mid] < val){
           return search(arr, val, mid + 1, right);
       } else {
           return mid;
       }
   }
   ```

2. 查找所有相同的数的索引

   ```java
   public static List<Integer> search(int[] arr, int val, int left, int right) {
       if (left > right) {
           return new ArrayList<>();
       }
       int mid = (left + right) / 2;
       if (arr[mid] > val) {
           return search(arr, val, left, mid - 1);
       } else if (arr[mid] < val){
           return search(arr, val, mid + 1, right);
       } else {
           ArrayList<Integer> result = new ArrayList<>();
           result.add(mid);
           int i = 1;
           int j = 1;
           while (mid + i <= right && arr[mid + i] == val) {
               result.add(mid + i);
               i++;
           }
           while (mid - j >= left && arr[mid - j] == val) {
               result.add(mid - j);
               j++;
           }
           return result;
       }
   }
   ```

## 二，插值查找

1. 插值查找原理介绍

   - 插值查找算法类似于二分查找，不同的是插值查找每次从自适应mid处开始查找

   - 将折半查找中的求mid索引的公式，low表示左边索引left，high表示右边索引right，val表示需要查找的值

     $$mid = \frac {low + high} 2 = low + \frac 1 2 (high - low)$$改为$$mid = low + \frac {val - arr[low]} {arr[high] - arr[low]} (high - low)$$

2. 代码实现

   ```java
   public static int search(int[] arr, int val, int left, int right) {
       if (left > right || val < arr[0] || val > arr[arr.length - 1]) {
           return -1;
       }
       int mid = left + (right - left) * (val - arr[left]) / (arr[right] - arr[left]);
       if (arr[mid] > val) {
           return search(arr, val, left, mid - 1);
       } else if (arr[mid] < val){
           return search(arr, val, mid + 1, right);
       } else {
           return mid;
       }
   }
   ```

3. 插值查找注意事项

   - 对于数据量较大，关键字分布比较均匀的查找表来说，采用插值查找，速度较快
   - 关键字分布不均匀的情况下，该方法不一定比折半查找要好

## 三，斐波那契（黄金分割法）查找

1. 基本介绍

   - 黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神奇的数字，会带来意向不大的效果。
   - 斐波那契数列{1,1,2,3,5,8,13,21,34,55}发现斐波那契数列的两个相邻数的比例，无限接近黄金分割值0.618

2. 斐波那契（黄金分割法）原理

   斐波那契查找原理与前两种相似，仅仅是改变了中间节点（mid）的位置，mid不再是中间或插值得到，而是位于黄金分割带你附近，即$mid = low + F(k-1) - 1$（F代表斐波那契数列）

   **对于F(k - 1) - 1的理解**

   - 由斐波那契数列F[k] = F[k - 1] + F[k - 2]的性质，可以得到(F[k] - 1) = (F[k - 1] - 1) + (F[k - 2] - 1) + 1。该式说明：只要顺序表的长度为F[k] - 1,则可以将该表分成长度为F[k - 1] - 1和F[k - 2] - 1的两段，即如上图所示。从而中间位置为mid = low + F(k - 1) - 1

   - 类似的，每一子段也可以用相同的方式分割

   - 但顺序表长度不一定刚收好等于F[k] - 1,所以需要将原来的顺序表长度n增加至F[k] - 1。这里的k值只要能使得F[k] - 1恰好大于或等于即可，由以下代码得到，顺序表长度增加后，新增的位置（从n+1到F[k] - 1位置)，都赋为n位置的值即可。

     ```java
     while (n > fib(k) - 1)
         k++;
     ```

3. 代码实现

   ```java
   /**
    * 将数组进行黄金分割查找
    * @param arr 数组
    * @param val 需要查找的值
    * @return 下标
    */
   public static int search(int[] arr, int val) {
       int low = 0;
       int high = arr.length - 1;
       int k = 0;//表示斐波那契分割值的下标
       int mid;
       int[] fib = fibonacci(20);
       //获取斐波那契分割数值的下标
       while (high > fib[k] - 1) {
           k++;
       }
       //因为fib[k]的值可能大于arr的长度，因此需要使用Arrays类，构造一个新的数组，不足的部分用0填充，赋给arr
       int[] temp = Arrays.copyOf(arr, fib[k]);
       //使用arr的最后的数值，替换填充到temp中的0
       for (int i = high + 1; i < temp.length; i++) {
           temp[i] = arr[high];
       }
       while (low <= high) {
           //计算mid
           mid = low + fib[k - 1] - 1;
           if (val < temp[mid]) {
               //向左继续查找
               high = mid - 1;
               //全部元素 = 前面的元素 + 后面的元素
               //即fib[k] = fib[k - 1] + fib[k - 2]
               //即前面的元素个数为fib[k - 1]个
               //按照前面元素的个数进行黄金分割时，k为当前k减一
               k--;
           } else if (val > temp[mid]) {
               //向右继续查找
               low = mid + 1;
               //全部元素 = 前面的元素 + 后面的元素
               //即fib[k] = fib[k - 1] + fib[k - 2]
               //即后面的元素个数为fib[k - 2]个
               //按照后面元素的个数进行黄金分割时，k为当前k减二
               k -= 2;
           } else {
               //因为数组经过扩容，所以mid是有可能大于high的
               if (mid <= high) {
                   return mid;
               } else {
                   return high;
               }
           }
       }
       return -1;
   }
   //获取斐波那契数列
   public static int[] fibonacci(int maxSize) {
       int[] fib = new int[maxSize];
       fib[0] = fib[1] = 1;
       for (int i = 2; i < maxSize; i++) {
           fib[i] = fib[i - 1] + fib[i - 2];
       }
       return fib;
   }
   ```

# 第八章 哈希表（散列表）

## 一，哈希表的基本介绍

散列表(Hash table，也叫哈希表)是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表

## 二，代码实现

```java
@Data
class Employee {
    private int id;
    private String name;
    private Employee next;

    public Employee(int id, String name) {
        this.id = id;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Employee{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }
}
class EmployeeLinkedList {
    private Employee head;

    public void list(int listNo) {
        if (head == null) {
            System.out.println("当前链表" + listNo + "为空");
            return;
        }
        Employee curEmp = this.head;
        while (curEmp != null) {
            System.out.print("第" + listNo + "条链表:" + curEmp);
            curEmp = curEmp.getNext();
        }
        System.out.println();
    }

    //添加员工
    public void add(Employee employee) {
        //如果添加的是第一个员工，直接将head指向他
        if (head == null) {
            head = employee;
            return;
        }
        Employee curEmp = this.head;
        while (curEmp.getNext() != null) {
            curEmp.setNext(curEmp.getNext());
        }
        curEmp.setNext(employee);
    }

    //根据id查找员工
    public Employee getEmpById(int id) {
        if (head == null) {
            System.out.println("未找到id为" + id + "的员工");
            return null;
        }
        Employee curEmp = this.head;
        while (curEmp != null) {
            if (curEmp.getId() == id) {
                return curEmp;
            }
            curEmp = curEmp.getNext();
        }
        System.out.println("未找到id为" + id + "的员工");
        return null;
    }

    //根据id删除员工
    public void deleteById(int id) {
        if (head == null) {
            System.out.printf("未找到id为%d的员工", id);
            return;
        }
        if (head.getId() == id) {
            head = head.getNext();
            return;
        }
        Employee curEmp = this.head;
        while (curEmp != null && curEmp.getNext() != null) {
            if (curEmp.getNext().getId() == id) {
                curEmp.setNext(curEmp.getNext().getNext());
                return;
            }
            curEmp = curEmp.getNext();
        }
        System.out.printf("未找到id为%d的员工", id);
    }
}
class HashTable {
    private EmployeeLinkedList[] employeeLinkedListArray;
    private int size;

    public HashTable(int size) {
        //初始化
        this.size = size;
        employeeLinkedListArray = new EmployeeLinkedList[size];
        for (int i = 0; i < size; i++) {
            employeeLinkedListArray[i] = new EmployeeLinkedList();
        }
    }

    public void add(Employee employee) {
        //根据员工的id得到应该添加到那条列表
        int listNo = hash(employee.getId());
        employeeLinkedListArray[listNo].add(employee);
    }

    public void list() {
        for (int i = 0; i < size; i++) {
            employeeLinkedListArray[i].list(i);
        }
    }

    public Employee getEmpById(int id) {
        int listNo = hash(id);
        return employeeLinkedListArray[listNo].getEmpById(id);
    }

    public void deleteById(int id) {
        int listNo = hash(id);
        employeeLinkedListArray[listNo].deleteById(id);
    }

    public int hash(int id) {
        return id % size;
    }
}
```

# 第九章 树

## 一，数组、链表、树存储方式分析

1. 为什么要有树这种数据结构

   - 数组存储方式的分析

     - 优点

       通过下标方式访问元素，速度快。对于有序数组，还可以使用二分查找提高检索速度

     - 缺点

       如果要检索具体某个值，或者插入值（按一定顺序）会整体移动，效率低

   - 链表存储方式的分析

     - 优点

       在一定程度上对数组存储方式有优化（比如：插入一个数值节点，只需要将插入节点，链接到链表中即可，删除效率也很好）

     - 缺点

       在进行检索时，效率任然很低

   - 树的存储方式的分析

     能提高数据存储，读取的效率，比如利用二叉排序树(Binary Sort Tree)，既可以保证数据的检索速度，同时也可以保证数据的插入，删除，修改的速度。

2. 树的常用术语

   ![](F:\截图\屏幕截图 2022-09-17 170621.png)

   - 节点
   - 根节点
   - 父节点
   - 子节点
   - 叶子节点
   - 节点的权（节点值）
   - 路径（从root节点找到该节点的路线）
   - 层
   - 子树
   - 树的高度（最大层数）
   - 森林（多颗子树构成森林）

## 二，二叉树

1. 二叉树的概念

   - 树有很多种，每个节点最多只能有两个子节点的一种形式称为二叉树。
   - 二叉树的子节点分为左节点和右节点。
   - 如果二叉树的所有叶子节点都在最后一层，并且节点总数为$2^n - 1$，n为层数，则我们称之为满二叉树
   - 如果二叉树的所有叶子节点都在最后一层或者倒数第二层，而且最后一层的叶子节点在左边连续，倒数第二层的叶子节点在右边连续，我们称之为完全二叉树

2. 二叉树的遍历

   - 前序遍历：先输出父节点，再遍历左子节点和右子节点
   - 中序遍历：先遍历左子树，再输出父节点，再遍历右子树
   - 后序遍历：先遍历左子树，再遍历右子树，最后输出父节点

   总结：看输出父节点的顺序，就确定是前序，中序还是后序

3. 前序遍历、中序遍历、后序遍历代码实现

   ```java
   class BinaryTree {
       private Node root;
   
       public void setRoot(Node root) {
           this.root = root;
       }
   
       public void preOrder() {
           if (this.root != null) {
               this.root.preOrder();
           } else {
               System.out.println("二叉树为空");
           }
       }
       public void infixOrder() {
           if (this.root != null) {
               this.root.infixOrder();
           } else {
               System.out.println("二叉树为空");
           }
       }
       public void postOrder() {
           if (this.root != null) {
               this.root.postOrder();
           } else {
               System.out.println("二叉树为空");
           }
       }
   }
   @Data
   class Node {
       private int no;
       private String name;
       private Node left;
       private Node right;
   
       public Node(int no, String name) {
           this.no = no;
           this.name = name;
       }
   
       @Override
       public String toString() {
           return "Node{" +
                   "no=" + no +
                   ", name='" + name + '\'' +
                   '}';
       }
   
       //前序遍历
       public void preOrder() {
           System.out.println(this);
           if (this.left != null) {
               this.left.preOrder();
           }
           if (this.right != null) {
               this.right.preOrder();
           }
       }
       //中序遍历
       public void infixOrder() {
           if (this.left != null) {
               this.left.infixOrder();
           }
           System.out.println(this);
           if (this.right != null) {
               this.right.infixOrder();
           }
       }
       //后序遍历
       public void postOrder() {
           if (this.left != null) {
               this.left.postOrder();
           }
           if (this.right != null) {
               this.right.postOrder();
           }
           System.out.println(this);
       }
   }
   ```

4. 前序、中序、后序查找

   ```java
   //前序查找
   public Node preSearch(int no) {
       if (this.getNo() == no) return this;
       Node target = null;
       if (this.left != null) target = this.left.preSearch(no);
       if (target != null) return target;
       if (this.right != null) target = this.right.preSearch(no);
       return target;
   }
   //中序查找
   public Node infixSearch(int no) {
       Node target = null;
       if (this.left != null) target = this.left.infixSearch(no);
       if (target != null) return target;
       if (this.getNo() == no) return this;
       if (this.right != null) target = this.right.infixSearch(no);
       return target;
   }
   //后序查找
   public Node postSearch(int no) {
       Node target = null;
       if (this.left != null) target = this.left.postSearch(no);
       if (target != null) return target;
       if (this.right != null) target = this.right.postSearch(no);
       if (target != null) return target;
       if (this.getNo() == no) return this;
       return null;
   }
   ```

5. 删除节点

   - 如果是删除叶子节点，则删除该节点
   - 如果删除的是非叶子节点，则删除该子树

   ```java
   public boolean delete(int no) {
       if (root == null) {
           System.out.println("空树，不能删除");
           return false;
       } else {
           if (root.getNo() == no) {
               root = null;
               return true;
           } else {
               return root.delete(no);
           }
       }
   }
   
   
   //递归删除节点
   public boolean delete(int no) {
       //如果左子节点不为空，并且左子节点就是要删除的节点，就将this.left = null;并返回
       if (this.left != null && this.left.no == no) {
           this.left = null;
           return true;
       }
       //如果右子节点不为空，并且右子节点就是要删除的节点，就将this.right = null;并返回
       if (this.right != null && this.right.no == no) {
           this.right = null;
           return true;
       }
       //向左递归
       if (this.left != null) {
           if (this.left.delete(no)) {
               return true;
           }
       }
       //向右递归
       if (this.right != null) {
           return this.right.delete(no);
       }
       return false;
   }
   ```

6. 顺序存储二叉树

   - 从数据存储来看，数组存储方式和树的存储方式可以相互转换，即数组可以转换成树，树也可以转换成数组。

   - 顺序存储二叉树通常只考虑完全二叉树
   - 第n个元素的左子节点为2*n+1
   - 第n个元素的右子节点为2*n+2
   - 第n个元素的父节点为(n-1)/2

## 三，线索化二叉树

1. 基本介绍

   - n个结点的二叉链表中含有n+1【公式2n-(n-1)=n+1】个空指针域。利用二叉链表中的空指针域，存放指向节点在某种遍历次序下的前驱和后继节点的指针（这种附加的指针称为"线索"）
   - 这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种
   - 一个节点的前一个节点，称为前驱节点
   - 一个节点的后一个节点，称为后继节点

2. 中序线索化代码实现

   ```java
   private TreeNode root;
   private TreeNode pre;//处理线索化时的前驱节点
   
   public void setRoot(TreeNode root) {
       this.root = root;
   }
   
   public void infixThreaded() {
       infixThreaded(root);
   }
   
   //中序线索化
   public void infixThreaded(TreeNode curNode) {
       //如果当前节点为null，不能线索化
       if (curNode == null) return;
   
       //线索化左子树
       infixThreaded(curNode.getLeft());
   
       //线索化当前节点
       if (curNode.getLeft() == null) {
           //让当前节点的左指针指向前驱节点
           curNode.setLeft(pre);
           //修改当前节点的左指针类型
           curNode.setLeftType(1);
       }
       if (pre != null && pre.getRight() == null) {
           //让当前节点的前驱节点的右指针指向当前节点
           pre.setRight(curNode);
           //修改当前节点的前驱节点的右指针类型
           pre.setRightType(1);
       }
       //线索化完成当前节点之后，让前驱节点指向当前节点
       pre = curNode;
   
       //线索化右子树
       infixThreaded(curNode.getRight());
   }
   ```

3. 遍历线索化二叉树

   ```java
   //中序线索化遍历
   public void infixThreadedList() {
       TreeNode curNode = this.root;
       while (curNode != null) {
           //向左循环查找，直到找到一个leftType为1的节点
           while (curNode.getLeftType() == 0) {
               curNode = curNode.getLeft();
           }
           System.out.println(curNode);
           //如果右节点为后继节点，就一直遍历输出
           while (curNode.getRightType() == 1) {
               curNode = curNode.getRight();
               System.out.println(curNode);
           }
           curNode = curNode.getRight();
       }
   }
   ```

## 四，堆排序

1. 基本介绍
   - 堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏，最好，平均时间复杂度均为$O(nlog\ n)$，它是不稳定排序
   - 堆是具有以下性质的完全二叉树：
     - 每个节点的值都大于或等于其左右子节点的值，称之为大顶堆
     - 每个节点的值都小于或等于其左右子节点的值，称之为小顶堆
   - 大顶堆特点：arr[i] >= arr[2 * i + 1] && arr[i] >= arr[2 * i + 2]
   - 小顶堆特点：arr[i] <= arr[2 * i + 1] && arr[i] <= arr[2 * i + 2]

2. 基本思路

   - 将待排序的序列构成一个大顶堆
   - 此时，整个序列的最大值就是堆顶的根节点
   - 将其与末尾元素进行交换，此时末尾就为最大值
   - 然后将剩余n-1个元素重新构建成一个堆，这样会得到n个元素的次小值，如此反复执行，便能得到一个有序序列了

3. 代码实现

   ```java
   public static void sort(int[] arr) {
       //先将arr变成大顶堆
       for (int i = arr.length / 2 - 1; i >= 0; i--) {
           adjust(arr, i, arr.length);
       }
       int temp;
       for (int i = arr.length - 1; i > 0; i--) {
           //将堆顶的数据和尾部数据交换
           temp = arr[i];
           arr[i] = arr[0];
           arr[0] = temp;
           //顶部的数据改变之后，重新调整，直接从arr[0]开始调整，因为底下已经是大顶堆，而且长度为i（最后一位数已经确定为最大值，不需要参与排序了）
           adjust(arr, 0, i);
       }
   }
   
   /**
    * 完成将以i为对应的非叶子节点的数调整为大顶堆
    * @param arr 需要调整的数组
    * @param i 非叶子节点在数组中的索引
    * @param length 表示对多少个元素继续调整
    */
   public static void adjust(int[] arr, int i, int length) {
       //左子节点
       int left = i * 2 + 1;
       //右子节点
       int right = i * 2 + 2;
       //先设置当前节点为最大值节点索引
       int largest = i;
       if (left < length && arr[left] > arr[largest]) {
           //如果左子节点大于当前节点将largest设置为left
           largest = left;
       }
       if (right < length && arr[right] > arr[largest]) {
           //如果右子节点大于当前节点将largest设置为right
           largest = right;
       }
       if (largest != i) {
           //如果largest改变了，就交换i和largest的值
           int temp = arr[i];
           arr[i] = arr[largest];
           arr[largest] = temp;
           //因为largest的值改变了，largest的下面也可能会有子节点，需要调整
           adjust(arr, largest, length);
       }
   }
   ```

## 五，赫夫曼树

1. 基本介绍

   - 给定个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度(wpl)达到最小，称这样的三叉树为最优二叉树，也称为哈夫曼树(HuffmanTree)
   - 赫夫曼树是带权路径长度最短的树，权值较大的结点离根较近。

2. 相关概念

   - 路径和路径长度：在一棵树中，从一个结点往下可以达到的孩子或孙子节点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根节点的层数为1，则从根节点到第L层节点的路径长度为L-1
   - 节点的权及带权路径长度：若将树中节点赋给一个有着某种含义的数值，则这个数值称为该节点的权。节点的带权路径长度为：从根节点到该节点之间的路径长度与该节点的权的乘积
   - 树的带权路径长度：树的带权路径长度规定为所有子节点的带权路径长度之和，记为WPL（weight path length），权值越大的节点离根节点越近的二叉树才是最优二叉树
   - WPL最小的就是赫夫曼树

3. 赫夫曼树创建步骤

   - 从小到大进行排序，将每一个数据，每个数据都是一个节点，每个节点可以看成是一颗最简单的二叉树
   - 取出根节点权值最小的两颗二叉树
   - 组成一颗新的二叉树，该新的二叉树的根节点的权值是前面两颗二叉树根节点权值的和
   - 再将这颗新的二叉树，以根节点的权值大小再次排序，不断重复1-2-3-4的步骤，直到数列中，所有的数据都被处理，就得到一个赫夫曼树

4. 代码实现

   ```java
   public static Node createHuffmanTree(int[] arr) {
       //将arr的每一个元素都创建成一个Node
       ArrayList<Node> nodes = new ArrayList<>();
       for (int value : arr) {
           nodes.add(new Node(value));
       }
       while (nodes.size() > 1) {
           //排序
           Collections.sort(nodes);
           //取出最小的节点和第二小的节点
           Node left = nodes.get(0);
           Node right = nodes.get(1);
           //创建一颗新的二叉树
           Node parent = new Node(left.getValue() + right.getValue());
           parent.setLeft(left);
           parent.setRight(right);
           //从nodes中删除处理过的二叉树，并且将新的二叉树添加到nodes中
           nodes.remove(left);
           nodes.remove(right);
           nodes.add(parent);
       }
       return nodes.get(0);
   }
   
   @Data
   class Node implements Comparable<Node>{
       private int value;
       private Node left;
       private Node right;
   
       public Node(int value) {
           this.value = value;
       }
   
       //前序遍历
       public void preOrder() {
           System.out.println(this);
           if (this.left != null) {
               this.left.preOrder();
           }
           if (this.right != null) {
               this.right.preOrder();
           }
       }
   
       @Override
       public String toString() {
           return "Node{" +
                   "value=" + value +
                   '}';
       }
   
       @Override
       public int compareTo(Node o) {
           return this.value - o.value;
       }
   }
   ```

## 六，赫夫曼编码

1. 基本介绍

   - 赫夫曼编码也翻译为哈夫曼编码(Huffman Coding)，是种编码方式，属于一种程序算法
   - 赫夫曼编码是赫哈夫曼树在电讯通信中的经典的应用之一。
   - 赫夫曼编码广泛地用于数据文件压缩。其压缩率通常在20%~90%之间
   - 赫夫曼码是可变字长编码(VLC)的一种。Huffman于1952年提出一种编码方法，称之为最佳编码

2. 数据压缩-创建赫夫曼树

   ```java
   public static List<Node> getNodes(byte[] bytes) {
       ArrayList<Node> nodes = new ArrayList<>();
       HashMap<Byte, Integer> counts = new HashMap<>();
       for (byte b : bytes) {
           Integer count = counts.get(b);
           if (count == null) counts.put(b, 1);
           else counts.put(b, count + 1);
       }
       counts.forEach(((b, count) -> {
           nodes.add(new Node(b, count));
       }));
       return nodes;
   }
   
   public static Node createHuffmanTree(List<Node> nodes) {
       while (nodes.size() > 1) {
           Collections.sort(nodes);
           Node left = nodes.get(0);
           Node right = nodes.get(1);
           Node parent = new Node(null, left.getWeight() + right.getWeight());
           parent.setLeft(left);
           parent.setRight(right);
           nodes.remove(left);
           nodes.remove(right);
           nodes.add(parent);
       }
       return nodes.get(0);
   }
   @Data
   class Node implements Comparable<Node>{
       private Byte data;//存放数据
       private Integer weight;//权值，表示字符出现的次数
       private Node left;
       private Node right;
   
       public Node(Byte data, Integer weight) {
           this.data = data;
           this.weight = weight;
       }
   
       //前序遍历
       public void preOrder() {
           System.out.println(this);
           if (this.left != null) this.left.preOrder();
           if (this.right != null) this.right.preOrder();
       }
   
       @Override
       public int compareTo(Node o) {
           return this.weight - o.weight;
       }
   
       @Override
       public String toString() {
           return "Node{" +
                   "data=" + data +
                   ", weight=" + weight +
                   '}';
       }
   }
   ```

3. 数据压缩-生成赫夫曼编码表

   ```java
   public static void huffmanCode(Node root, Map<Byte, String> huffmanCodes) {
       huffmanCode(root, "", new StringBuilder(), huffmanCodes);
   }
   
   public static void huffmanCode(Node node, String path, StringBuilder builder, Map<Byte, String> huffmanCodes) {
       //创建一个新的StringBuilder，不然每次递归的StringBuilder会相互影响
       StringBuilder stringBuilder = new StringBuilder(builder);
       //拼接路径
       stringBuilder.append(path);
       //如果node为空，直接结束方法
       if (node != null) {
           //node.getData() == null表示当前节点为非叶子节点
           if (node.getData() == null) {
               //向左递归
               huffmanCode(node.getLeft(), "0", stringBuilder, huffmanCodes);
               //向右递归
               huffmanCode(node.getRight(), "1", stringBuilder, huffmanCodes);
           } else {
               //node.getData() != null表示当前节点为叶子节点，添加到map中
               huffmanCodes.put(node.getData(), stringBuilder.toString());
           }
       }
   }
   ```

4. 数据压缩-生成赫夫曼编码字节数组

   ```java
   public static byte[] zip(byte[] bytes, Map<Byte, String> huffmanCodes) {
       //利用huffmanCodes将bytes转成赫夫曼编码对应的字符串
       StringBuilder builder = new StringBuilder();
       for (byte b : bytes) {
           builder.append(huffmanCodes.get(b));
       }
       //统计huffmanCodesBytes的长度
       int len = (builder.length() + 7) / 8;
       byte[] huffmanCodesBytes = new byte[len];
       int index = 0;//记录存放的是第几个byte
       for (int i = 0; i < builder.length(); i += 8) {
           String strByte;
           if (i + 8 > builder.length()) {
               strByte = builder.substring(i);
           } else {
               strByte = builder.substring(i, i + 8);
           }
           //将strByte转成一个byte，放入到huffmanCodesBytes中
           huffmanCodesBytes[index] = (byte) Integer.parseInt(strByte, 2);
           index++;
       }
       return huffmanCodesBytes;
   }
   ```

5. 数据解压-字节转二进制字符串

   ```java
   /**
    * 将一个byte转成一个二进制的字符串
    * @param b 需要转换的byte
    * @param flag 标志是否需要补高位
    * @return
    */
   public static String byteToBitString(byte b, boolean flag) {
       int temp = b;//将b转成int
       if (flag) {
           temp |= 256;//按位与256   1 0000 0000 | 0000 0001 => 1 0000 0001
       }
       String str = Integer.toBinaryString(temp);
       if (flag) {
           return str.substring(str.length() - 8);//截取后八位
       } else {
           return str;//如果b是最后一个，可能不足8位
       }
   }
   ```

6. 数据解压-赫夫曼解码

   ```java
   public static byte[] decode(byte[] huffmanCodesBytes) {
       StringBuilder builder = new StringBuilder();
       //将byte数组转成二进制的字符串
       for (int i = 0; i < huffmanCodesBytes.length; i++) {
           boolean flag = (i == huffmanCodesBytes.length - 1);
           builder.append(byteToBitString(huffmanCodesBytes[i], !flag));
       }
       //把字符串按照指定的赫夫曼编码进行解码
       //把赫夫曼编码表进行调换
       HashMap<String, Byte> huffmanCodesString = new HashMap<>();
       for (Map.Entry<Byte, String> entry : huffmanCodes.entrySet()) {
           huffmanCodesString.put(entry.getValue(), entry.getKey());
       }
       //创建一个集合存放byte
       ArrayList<Byte> byteList = new ArrayList<>();
       int count = 0;//上一次成功匹配到一个key时的索引
       boolean flag;//是否匹配到key
       for (int i = 1; i <= builder.length(); i++) {
           flag = huffmanCodesString.containsKey(builder.substring(count, i));
           if (flag) {
               Byte b = huffmanCodesString.get(builder.substring(count, i));
               byteList.add(b);
               count = i;
           }
       }
       byte[] decodeResult = new byte[byteList.size()];
       for (int i = 0; i < byteList.size(); i++) {
           decodeResult[i] = byteList.get(i);
       }
       return decodeResult;
   }
   ```

7. 文件压缩

   ```java
   public static void zipFile(String srcFile, String destFile) {
       FileInputStream inputStream = null;
       FileOutputStream outputStream = null;
       ObjectOutputStream objectOutputStream = null;
       try {
           inputStream = new FileInputStream(srcFile);
           byte[] bytes = new byte[inputStream.available()];
           inputStream.read(bytes);
           byte[] huffmanZip = huffmanZip(bytes);
           outputStream = new FileOutputStream(destFile);
           objectOutputStream = new ObjectOutputStream(outputStream);
           objectOutputStream.writeObject(huffmanZip);
           objectOutputStream.writeObject(huffmanCodes);
       } catch (Exception e) {
           e.printStackTrace();
       } finally {
           try {
               inputStream.close();
               outputStream.close();
               objectOutputStream.close();
           } catch (IOException e) {
               e.printStackTrace();
           }
       }
   }
   ```

8. 文件解压

   ```java
   public static void unZipFile(String zipFile, String destFile) {
       FileInputStream inputStream = null;
       ObjectInputStream objectInputStream = null;
       FileOutputStream outputStream = null;
       try {
           inputStream = new FileInputStream(zipFile);
           objectInputStream = new ObjectInputStream(inputStream);
           byte[] huffmanBytes = (byte[]) objectInputStream.readObject();
           Map<Byte, String> huffmanCodes = (Map<Byte, String>) objectInputStream.readObject();
           byte[] decode = decode(huffmanBytes, huffmanCodes);
           outputStream = new FileOutputStream(destFile);
           outputStream.write(decode);
       } catch (Exception e) {
           e.printStackTrace();
       } finally {
           try {
               outputStream.close();
               objectInputStream.close();
               inputStream.close();
           } catch (IOException e) {
               e.printStackTrace();
           }
       }
   }
   ```

9. 赫夫曼编码压缩文件注意事项

   - 如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化
   - 赫夫曼编码是按照字节来处理的，因此可以处理所有的文件（二进制文件、文本文件）
   - 如果一个文件中的内容重复的数据不多，压缩效果也不会很明显

## 七，二叉排序树

1. 二叉排序树介绍

   二叉排序树：BST(Binary Sort(Search) Tree)，对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。

   **特别说明**：如果有相同的值，可以将该节点放在左子节点或右子节点

2. 二叉排序树创建和遍历

   ```java
   class BinarySortTree {
       private Node root;
   
       public void add(Node node) {
           if (root == null) root = node;
           else root.add(node);
       }
   
       public void infixOrder() {
           if (root == null) System.out.println("空树-------");
           else root.infixOrder();
       }
   }
   @Data
   class Node {
       private int value;
       private Node left;
       private Node right;
   
       public Node(int value) {
           this.value = value;
       }
   
       //添加
       public void add(Node node) {
           if (node == null) return;
   
           if (node.value < this.value) {
               if (this.left == null) {
                   this.left = node;
               } else {
                   this.left.add(node);
               }
           } else {
               if (this.right == null) {
                   this.right = node;
               } else {
                   this.right.add(node);
               }
           }
       }
   	
       //中序遍历
       public void infixOrder() {
           if (this.left != null) this.left.infixOrder();
           System.out.println(this);
           if (this.right != null) this.right.infixOrder();
       }
   
       @Override
       public String toString() {
           return "Node{" +
                   "value=" + value +
                   '}';
       }
   }
   ```

3. 删除

   ```java
   public void delete(int value) {
       if (root == null) return;
       else {
           Node target = root.search(value);
           if (target == null) return;
           Node parent = root.searchParent(value);
           if (target.getLeft() == null && target.getRight() == null) {
               if (target == root) {
                   root = null;
                   return;
               }
               //如果删除的节点时叶子节点
               if (parent.getLeft() == target) parent.setLeft(null);
               else parent.setRight(null);
               return;
           } else if (target.getLeft() != null && target.getRight() != null) {
               //如果删除的节点是有两颗子树的节点
               //从左子树中查找最大的value
               Node temp = target.getLeft();
               int maxVal = temp.getValue();
               while (temp.getRight() != null) {
                   temp = temp.getRight();
                   if (temp.getValue() > maxVal) maxVal = temp.getValue();
               }
               //删除这个最大的节点
               delete(temp.getValue());
               //将target的value设置为maxVal
               target.setValue(maxVal);
               return;
           } else {
               //如果删除的节点时只有一颗子树的节点
               if (target.getLeft() != null) {
                   if (parent.getLeft() == target) parent.setLeft(target.getLeft());
                   else parent.setRight(target.getLeft());
               } else {
                   if (parent.getLeft() == target) parent.setLeft(target.getRight());
                   else parent.setRight(target.getRight());
               }
               return;
           }
       }
   }
   
   
   //查找
   public Node search(int value) {
       if (value == this.value) return this;
       else if (value < this.value) {
           if (this.left != null) return this.left.search(value);
       }
       else {
           if (this.right != null) return this.right.search(value);
       }
       return null;
   }
   
   //查找要删除的节点的父节点
   public Node searchParent(int value) {
       if ((this.left != null && this.left.value == value)
           || (this.right != null && this.right.value == value))
           return this;//找到要删除节点的父节点，直接返回
       else {
           if (value < this.value && this.left != null) {
               //向左递归
               return this.left.searchParent(value);
           } else if (value >= this.value && this.right != null) {
               //向右递归
               return this.right.searchParent(value);
           } else return null;
       }
   }
   ```

## 八，平衡二叉树

1. 基本介绍

   - 平衡二叉树也叫平衡二叉搜索树(Self-balancing binary search tree)又被称为AVL树，可以保证查询效率较高。
   - 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。

2. 代码实现

   ```java
   //返回左子树的高度
   public int leftHeight() {
       return left == null ? 0 : left.height();
   }
   
   //返回右子树的高度
   public int rightHeight() {
       return right == null ? 0 : right.height();
   }
   
   //返回以当前节点为根节点的树的高度
   public int height() {
       return Math.max(left == null ? 0 : left.height(), right == null ? 0 : right.height()) + 1;
   }
   
   //左旋转
   public void leftRotate() {
       //以当前根节点的值创建新的节点
       Node newNode = new Node(value);
       //把新节点的左子树设置为当前节点的左子树
       newNode.left = this.left;
       //把新节点的右子树设置为当前节点的右子树的左子树
       newNode.right = this.right.left;
       //把当前节点的值换位右子节点的值
       this.value = this.right.value;
       //把当前节点的右子树设置成右子树的右子树
       this.right = this.right.right;
       //把当前节点的左子树设置为新节点
       this.left = newNode;
   }
   
   //右旋转
   public void rightRotate() {
       //以当前节点创建新的节点
       Node newNode = new Node(this.value);
       //把新节点的右子树设置为当前节点的右子树
       newNode.right = this.right;
       //把新节点的左子树设置为当前节点的左子树的右子树
       newNode.left = this.left.right;
       //把当前节点的右子树设置为新节点
       this.right = newNode;
       //把当前节点的值设置为左子节点的值
       this.value = this.left.value;
       //把当前节点的左子节点设置为左子节点的左子节点
       this.left = this.left.left;
   }
   
   //添加
   public void add(Node node) {
       if (node == null) return;
   
       if (node.value < this.value) {
           if (this.left == null) {
               this.left = node;
           } else {
               this.left.add(node);
           }
       } else {
           if (this.right == null) {
               this.right = node;
           } else {
               this.right.add(node);
           }
       }
       //如果右子树比左子树高度大于1，左旋转
       if (rightHeight() - leftHeight() > 1) {
           if (right != null && right.leftHeight() > right.rightHeight()) {
               //如果当前节点的右子树的左子树高度大于右子树高度，需要先对当前节点的右子树右旋转
               right.rightRotate();
           }
           leftRotate();
       }
       //如果左子树比右子树高度大于1，右旋转
       if (leftHeight() - rightHeight() > 1) {
           if (left != null && left.rightHeight() > left.leftHeight()) {
               //如果当前节点的右子树高度大于左子树高度，需要先对当前节点的左子树左旋转
               left.leftRotate();
           }
           rightRotate();
       }
   }
   ```

## 九，多路查找树

1. 多叉树

   - 在二叉树中，每个节点都有数据项，最多有两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点，就是多叉树（multiway tree）
   -  多叉树通过重新组织节点，减少数的高度，能对二叉树进行优化

2. B树的基本介绍

   B树通过重新组织节点，降低树的高度，并且减少I/O读写次数来提升效率

   - 文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页（页的大小通常为4k），这样每个节点只需要一次I/O就可以完全载入
   - 将树的度M设置为1024，在600亿个元素中最多只需要4次I/O就可以读取到想要的元素，B树（B+树）广泛的应用于文件存储系统以及数据库系统中

3. 2-3树基本介绍

   2-3树是最简单的B树结构

   - 2-3树的所有叶子节点都在同一层（只要是B树就满足这个条件）
   - 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点
   - 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点
   - 2-3树是有二节点和三节点构成的树

4. B树基本介绍

   - B树的阶：节点的最多子节点个数。比如2-3树的阶是3，2-3-4树的阶是4
   - B树的搜索：从根节点开始，对节点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进行查询关键字所属范围的子节点；重复，直到对应的子节点指针为空，或已经是叶子节点
   - 关键字集合分布在整颗树中，即叶子节点和非叶子节点都存放数据
   - 搜索有可能在非叶子节点结束
   - 其搜索性能等价于在关键字全集内做一次二分查找

5. B+树基本介绍

   - B+树的搜索与B树也基本相同，区别是B+树只有达到叶子节点才命中（B树可以在非叶子节点命中），其性能也等价于在关键字全集做一次二分查找
   - 所有关键字都出现在叶子节点的链表中（即数据只能在叶子节点【也叫稠密索引】)，且链表中的关键字数据恰好是有序的。
   - 不可能在非叶子节点命中
   - 非叶子节点相当于是叶子节点的索引（稀疏索引）叶子节点相当于是存储（关键字）数据的数据层
   - 更适合文件索引系统
   - B树和B+树各有自己的应用场景，不能说B+树完全比B树好，反之亦然

6. B*树基本介绍

   - B*树定义了非叶子节点关键字个数至少为(2/3)\*M，即块的最低使用率为2/3，而B+树的块最低使用率为B+树的1/2
   - B*树分配新节点的概率比B+树要低，空间使用率更低

# 第十章 图

## 一，图的基本介绍

1. 图的基本介绍

   图是一种数据结构，其中节点可以具有零个或者多个相邻元素。两个节点之间的连接称之为边，节点也可以称之为顶点

2. 图的常用概念

   - 顶点
   - 边
   - 路径
   - 无向图：顶点之间没有方向
   - 有向图：顶点之间有方向
   - 带权图：边带有权值的图，这种图也叫作网

3. 图的表示方式

   图的表示方式有两种：二维数组（邻接矩阵），链表表示（邻接表）

   - 邻接矩阵：邻接矩阵是表示图形中的顶点之间相邻关系的矩阵，对于n个顶点的图而言，矩阵是row和col表示的是1....n个点

     ![](F:\截图\屏幕截图 2022-09-23 153046.png)

   - 邻接表：

     - 邻接矩阵需要为每个顶点都分配n个边的空间，其实有很多边都是不存在的，会造成空间的一定所示
     - 邻接表的实现只关心存在的边，不关心不存在的边，因此没有空间的浪费，邻接表有数据+链表组成
     - ![](F:\截图\屏幕截图 2022-09-23 153206.png)

4. 创建图代码实现

   ```java
   public class Graph {
       private ArrayList<String> vertexList;//存储顶点集合
       private int[][] edges;//存储图对应的邻接矩阵
       private int edgesSize;//边的数目
   
       public static void main(String[] args) {
           String[] vertexVal = {"A", "B", "C", "D", "E"};
           Graph graph = new Graph(vertexVal.length);
           for (String vertex : vertexVal) {
               graph.insertVertex(vertex);
           }
           //A-B A-C B-C B-D B-E
           graph.insertEdge(0, 1, 1);
           graph.insertEdge(0, 2, 1);
           graph.insertEdge(1, 2, 1);
           graph.insertEdge(1, 3, 1);
           graph.insertEdge(1, 4, 1);
   
           graph.showGraph();
       }
   
       public Graph(int n) {
           //初始化矩阵和vertexList
           edges = new int[n][n];
           vertexList = new ArrayList<>(n);
           edgesSize = 0;
       }
   
       //插入顶点
       public void insertVertex(String vertex) {
           vertexList.add(vertex);
       }
   
       /**
        * 添加边
        * @param v1 表示顶点的下标即第几个顶点
        * @param v2 表示第二个顶点的下标
        * @param weight 表示权重
        */
       public void insertEdge(int v1, int v2, int weight) {
           edges[v1][v2]  = weight;
           edges[v2][v1]  = weight;
           edgesSize++;
       }
   
       //返回顶点的个数
       public int getVertexSize() {
           return vertexList.size();
       }
   
       //返回边的数目
       public int getEdgesSize() {
           return edgesSize;
       }
   
       //返回顶点i（下标）对应的数据
       public String getVertexByIndex(int i) {
           return vertexList.get(i);
       }
   
       //返回v1和v2的权值
       public int getWeight(int v1, int v2) {
           return edges[v1][v2];
       }
       
       //显示图对应的矩阵
       public void showGraph() {
           for (int[] edge : edges) {
               System.out.println(Arrays.toString(edge));
           }
       }
   }
   ```

## 二，图的深度优先（DFS）遍历

1. 基本介绍

   - 深度优先遍历，从初始访问顶点出发，初始访问顶点可能有多个邻接顶点，深度优先遍历的策略就是首先访问第一个邻接顶点，然后再以这个被访问的邻接顶点作为初始顶点，访问它的第一个邻接顶点。每次都在访问完当前顶点后首先访问当前顶点的第一个邻接顶点
   - 这样的访问策略是优先往纵向挖掘深入，而不是对一个顶点的所有邻接顶点进行横向访问
   - 显然，深度优先是一个递归的过程

2. 代码实现

   ```java
   //深度优先遍历
   private void depthFirstSearch(List<String> out, int i) {
       String vertex = vertexList.get(i);
       if (!out.contains(vertex)) {
           System.out.println(vertex);
           out.add(vertex);
       } else return;
       for (int j = 1; j < vertexList.size() - i; j++) {
           if (edges[i][i + j] > 0) {
               depthFirstSearch(out, i + j);
           }
       }
   }
   
   public void depthFirstSearch() {
       ArrayList<String> out = new ArrayList<>();
       depthFirstSearch(out, 0);
   }
   ```

## 三，图的广度优先（BFS）遍历

1. 基本介绍

   图的广度优先搜索，类似于一个分层的过程，广度优先遍历需要使用一个队列以保持访问过的顶点的顺序，以便按这个顺序来访问这些顶点的邻接顶点

2. 代码实现

   ```java
   //广度优先遍历
   private void breadthFirstSearch(List<String> out) {
       for (int i = 0; i < vertexList.size(); i++) {
           String vertex = vertexList.get(i);
           if (!out.contains(vertex)) {
               System.out.println(vertex);
               out.add(vertex);
           }
           for (int j = 1; j < vertexList.size() - i; j++) {
               if (edges[i][i + j] > 0) {
                   vertex = vertexList.get(i + j);
                   if (!out.contains(vertex)) {
                       System.out.println(vertex);
                       out.add(vertex);
                   }
               }
           }
       }
   }
   
   private void breadthFirstSearch() {
       ArrayList<String> out = new ArrayList<>();
       breadthFirstSearch(out);
   }
   ```

# 第十一章 常用的十种算法

