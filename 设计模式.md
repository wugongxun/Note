# 第一章 七大设计原则

## 一，设计模式的目的

编写软件过程中，程序员面临着来自（耦合性）内聚性以及可维护性，可扩展性，重用性，灵活性等多方面的挑战，设计模式是为正程序（软件），具有更好

- 代码重用性
- 可读性
- 可扩展性
- 可靠性
- 高内聚，低耦合的特性

## 二，单一职责原则

1. 基本介绍

   对类来说的，即一个类应该只负责一如类A负责两个不同职责：职责1，职责2。当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为 A1，A2

2. 案例

   - ```java
     //违反单一职责原则
     public class SingleResponsibility {
         public static void main(String[] args) {
             Vehicle vehicle = new Vehicle();
             vehicle.run("car");
             vehicle.run("plane");
         }
     }
     
     class Vehicle {
         public void run(String vehicle) {
             System.out.println(vehicle + " is running...");
         }
     }
     ```

   - ```java
     //遵守单一职责原则，但是改动太大
     public class SingleResponsibility {
         public static void main(String[] args) {
             RoadVehicle roadVehicle = new RoadVehicle();
             roadVehicle.run("car");
             AirVehicle airVehicle = new AirVehicle();
             airVehicle.run("plane");
         }
     }
     
     class RoadVehicle {
         public void run(String vehicle) {
             System.out.println(vehicle + " is running...");
         }
     }
     
     class AirVehicle {
         public void run(String vehicle) {
             System.out.println(vehicle + " is flying...");
         }
     }
     ```

3. 注意事项和细节
   - 降低类的复杂度，一个类只负责一项职责。
   - 提高类的可读性，可维护性
   - 降低变更引起的风险
   - 通常情沉下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则

## 三，接口隔离原则

1. 基本介绍

   客户端不应该依赖它不需要的接口，即一个类对另二个类的依赖应该建立在最小的接口上

2. 案例

   ```java
   interface Interface1 {
       void operation1();
   }
   
   interface Interface2 {
       void operation2();
       void operation3();
   }
   
   interface Interface3 {
       void operation4();
       void operation5();
   }
   
   class A {
       public void depend1(Interface1 i) {
           i.operation1();
       }
       public void depend2(Interface2 i) {
           i.operation2();
       }
       public void depend3(Interface2 i) {
           i.operation3();
       }
   }
   
   class C {
       public void depend1(Interface1 i) {
           i.operation1();
       }
       public void depend4(Interface3 i) {
           i.operation4();
       }
       public void depend5(Interface3 i) {
           i.operation5();
       }
   }
   
   class B implements Interface1, Interface2 {
       @Override
       public void operation1() {
           System.out.println("B 实现了 operation1");
       }
   
       @Override
       public void operation2() {
           System.out.println("B 实现了 operation2");
       }
   
       @Override
       public void operation3() {
           System.out.println("B 实现了 operation3");
       }
   }
   
   class D implements Interface1, Interface3 {
       @Override
       public void operation1() {
           System.out.println("D 实现了 operation1");
       }
   
       @Override
       public void operation4() {
           System.out.println("D 实现了 operation4");
       }
   
       @Override
       public void operation5() {
           System.out.println("D 实现了 operation5");
       }
   }
   ```

## 四，依赖倒转（倒置）原则

1. 基本介绍

   - 高层模块应该依赖低层模块，二者都应该依赖其抽象
   - 抽象不应该依赖细节，细节应该依赖抽象
   - 依赖倒转（倒置）的中心思想是面向接口编程
   - 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类
   - 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成

2. 案例

   ```java
   public class DependenceInversion {
       public static void main(String[] args) {
           Person person = new Person();
           person.receive(new Email());
           person.receive(new Message());
       }
   }
   
   interface Receivable {
       void getInfo();
   }
   
   class Email implements Receivable {
       @Override
       public void getInfo() {
           System.out.println("email info...");
       }
   }
   
   class Message implements Receivable {
       @Override
       public void getInfo() {
           System.out.println("message info...");
       }
   }
   
   class Person {
       public void receive(Receivable receivable) {
           receivable.getInfo();
       }
   }
   ```

3. 注意事项和细节

   - 低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好
   - 变量的声明类型尽量是抽象类或接口，这我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化
   - 继承时遵循里氏替换原则

## 五，里氏替换原则

1. 基本介绍
   - 如果对每个类型为T1的对象o1，都有类型为T2的对象o2,使得以T1定义的所有程序 P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。在
   - 使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法
   - 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。

## 六，开闭原则

1. 基本介绍

   - 开闭原则(Open Closed Principle)是编程中最基础、最重要的设计原则
   - 一个软件实体如类，模块和函数应该对扩展开放，对修改关闭。用抽象构建框架，用实现扩展细节。
   - 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。
   - 编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。

2. 案例

   ```java
   //违背OCP原则，如果需要添加新的图形，需要修改使用方
   public class Ocp {
       public static void main(String[] args) {
           GraphicEditor editor = new GraphicEditor();
           editor.drawShape(new Rectangle());
           editor.drawShape(new Circle());
       }
   }
   
   class Shape {
       int type;
   }
   
   class Rectangle extends Shape {
       public Rectangle() {
           super.type = 1;
       }
   }
   
   class Circle extends Shape {
       public Circle() {
           super.type = 2;
       }
   }
   
   class GraphicEditor {
       public void drawShape(Shape shape) {
           if (shape.type == 1) {
               System.out.println("绘制矩形");
           } else if (shape.type == 2) {
               System.out.println("绘制圆形");
           }
       }
   }
   ```

   ```java
   //符合ocp原则
   public class Ocp {
       public static void main(String[] args) {
           GraphicEditor editor = new GraphicEditor();
           editor.drawShape(new Rectangle());
           editor.drawShape(new Circle());
       }
   }
   
   abstract class Shape {
       abstract void draw();
   }
   
   class Rectangle extends Shape {
       @Override
       public void draw() {
           System.out.println("绘制矩形");
       }
   }
   
   class Circle extends Shape {
       @Override
       public void draw() {
           System.out.println("绘制圆形");
       }
   }
   
   class GraphicEditor {
       public void drawShape(Shape shape) {
           shape.draw();
       }
   }
   ```

## 七，迪米特法则

1. 基本介绍

   - 一个对象应该对其他对象保持最少的了解
   - 类与类关系越密切，耦合度越大
   - 迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public方法，不对外泄露任何信息
   - 迪米特法则还有个更简单的定义：只与直接的朋友通信
   - ==直接的朋友==：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现**成员变量**，**方法参数**，**方法返回值**中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。

2. 案例

   ```java
   public class Demeter {
       public static void main(String[] args) {
           SchoolManager schoolManager = new SchoolManager();
           schoolManager.printAllEmployees(new EmployeeManager());
       }
   }
   
   class Employee {
       int id;
   }
   
   class EmployeeManager {
       public List<Employee> getEmployees() {
           ArrayList<Employee> employees = new ArrayList<>();
           for (int i = 0; i < 10; i++) {
               Employee employee = new Employee();
               employee.id = i;
               employees.add(employee);
           }
           return employees;
       }
   }
   
   class SchoolManager {
       public void printAllEmployees(EmployeeManager employeeManager) {
           //违反了迪米特法则，应为Employee不是SchoolManager的直接朋友，不应该直接使用Employee
           List<Employee> employees = employeeManager.getEmployees();
   
           for (Employee employee : employees) {
               System.out.println(employee.id);
           }
       }
   }
   ```

   ```java
   public class Demeter {
       public static void main(String[] args) {
           SchoolManager schoolManager = new SchoolManager();
           schoolManager.printAllEmployees(new EmployeeManager());
       }
   }
   
   class Employee {
       int id;
   }
   
   class EmployeeManager {
       public List<Employee> getEmployees() {
           ArrayList<Employee> employees = new ArrayList<>();
           for (int i = 0; i < 10; i++) {
               Employee employee = new Employee();
               employee.id = i;
               employees.add(employee);
           }
           return employees;
       }
   
       public void printAllEmployees() {
           List<Employee> employees = getEmployees();
   
           for (Employee employee : employees) {
               System.out.println(employee.id);
           }
       }
   }
   
   class SchoolManager {
       public void printAllEmployees(EmployeeManager employeeManager) {
           //遵守迪米特法则，EmployeeManager是SchoolManager的直接朋友，可以使用
           employeeManager.printAllEmployees();
       }
   }
   ```

3. 注意事项和细节

   - 迪米特法则的核心是降低类之间的耦合
   - 由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间（对象间）耦合关系，并不是要求完全没有依赖天系

## 八，合成复用原则

1. 基本介绍

   原则是尽量使用合成/聚合的方式，而不是使用继承

# 第二章 UML类图

## 一，基本介绍

1. UML——Unified modeling language UML(统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果
2. UML本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等
3. 使用UML来建模，常用的工具有Rational Rose，也可以使用一些插件来建模

## 二，类与类之间的关系

1. 依赖

   只要是类中使用到了对方，那么他们之间就存在依赖关系。如果没有对方，连编译都通过不了

   ![](F:\截图\屏幕截图 2023-04-11 160332.png)

2. 泛化

   泛化关系实际上就是继承关系，他是依赖关系的特例

   ![](F:\截图\屏幕截图 2023-04-11 160606.png)

3. 实现

   实现关系实际上就是A类实现了B类，他是依赖关系的特例

   ![](F:\截图\屏幕截图 2023-04-11 161045.png)

4. 关联

   关联关系实际上就是类与类之间的联系，他是依赖关系的特例

   关联具有导航性：即双向关系或单向关系

   关联具有多重性：如

5. 聚合

   聚合关系（Aggregation）表示的是整体和部分的关系，整体与部分可以分开。聚合关系是关联关系的特例，所以他具有关联关系的导航性与多重性

   如：一台电脑由键盘、显示器、鼠标等组成，组成电脑的各个配件是可以从电脑上分离出来的

   ![](F:\截图\屏幕截图 2023-04-11 161949.png)

6. 组合

   组合也是整体与部分的关系，但是整体与部分不可以分开

   ![](F:\截图\屏幕截图 2023-04-11 162355.png)

# 第三章 单例模式

1. 基本介绍

   所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（静态方法）。

2. 饿汉式（静态常量）

   - 构造器私有化

   - 类的内部创建对象

   - 对外暴露一个静态的公共方法

   - ```java
     class Singleton1 {
         //构造器私有化
         private Singleton1() {}
         //类的内部创建对象
         private final static Singleton1 instance = new Singleton1();
         //对外暴露一个静态的公共方法
         public static Singleton1 getInstance() {
             return instance;
         }
     }
     ```

   优缺点：

   - 这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。
   - 在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，在单例模式中大多数都是调用getInstance方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance就没有达到lazy loading的效果

3. 饿汉式（静态代码块）

   ```java
   class Singleton2 {
       private static Singleton2 instance;
       //构造器私有化
       private Singleton2() {}
       static {
           instance = new Singleton2();
       }
       //对外暴露一个静态的公共方法
       public static Singleton2 getInstance() {
           return instance;
       }
   }
   ```

4. 懒汉式（线程不安全）

   ```java
   class Singleton3 {
       private static Singleton3 instance;
       private Singleton3() {}
       public static Singleton3 getInstance() {
           if (instance == null) {
               instance = new Singleton3();
           }
           return instance;
       }
   }
   ```

   优缺点：

   - 起到了Lazy Loading的效果，但是只能在单线程下使用
   - 如果在多线程下，一个线程进入了if判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式

5. 懒汉式（线程安全，同步方法）

   ```java
   class Singleton4 {
       private static Singleton4 instance;
       private Singleton4() {}
       public synchronized static Singleton4 getInstance() {
           if (instance == null) {
               instance = new Singleton4();
           }
           return instance;
       }
   }
   ```

   优缺点：

   - 解决了线程不安全问题
   - 效率太低了，每个线程在想获得类的实例时侯候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低

6. 懒汉式（线程安全，双重检查）

   ```java
   class Singleton5 {
       private static volatile Singleton5 instance;
       private Singleton5() {}
       public static Singleton5 getInstance() {
           if (instance == null) {
               synchronized (Singleton5.class) {
                   if (instance == null) {
                       instance = new Singleton5();
                   }
               }
           }
           return instance;
       }
   }
   ```

   优缺点分析：

   - Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两次`if (instance = null)`检查，这样就可以保证线程安全了。
   - 这样，实例化代码只用执行一次，后面再次访问时，判断`if (singleton = null)`,直接return实例化对象，也避免的反复进行方法同步

7. 静态内部类

   ```java
   class Singleton6 {
       //构造器私有化
       private Singleton6() {}
       private static class Singleton {
           private static final Singleton instance = new Singleton();
       }
       public static Singleton getInstance() {
           return Singleton.instance;
       }
   }
   ```

   优缺点：

   - 这种方式采用了类装载的机制来保证初始化实例时只有一个线程。
   - 静态内部类方式在Singleton6类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载Singleton类，从而完成Singleton的实例化
   - 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。

8. 枚举

   ```java
   public class SingletonType7 {
       public static void main(String[] args) {
           System.out.println(Singleton7.INSTANCE == Singleton7.INSTANCE);
       }
   }
   
   enum Singleton7 {
       INSTANCE
   }
   ```

   优缺点：

   - 这借助JDK1.5中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。
   - 这种方式是Effective Java作者Josh Bloch提倡的方式

9. 单例模式注意事项和细节说明

   - 单例模式保证了系统内在中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能
   - 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用new
   - 单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多（即：重量级对象），但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象（比如数据源、session工厂等）

# 第四章 工厂模式

## 一，简单工厂模式

1. 基本介绍

   - 简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式
   - 简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为（代码）
   - 在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式

2. 披萨案例

   - 披萨抽象类

     ```java
     public abstract class Pizza {
         private String name;
     
         public abstract void prepare();
     
         public void make() {
             System.out.println("make " + name + " pizza");
         }
     
         public void cut() {
             System.out.println("cut " + name + " pizza");
         }
     
         public void box() {
             System.out.println("box " + name + " pizza");
         }
     
         public void setName(String name) {
             this.name = name;
         }
     }
     ```

   - 披萨实现类

     ```java
     public class GreekPizza extends Pizza {
         @Override
         public void prepare() {
             System.out.println("prepare GreekPizza...");
         }
     }
     ```

     ```java
     public class CheesePizza extends Pizza{
         @Override
         public void prepare() {
             System.out.println("prepare CheesePizza...");
         }
     }
     ```

   - 披萨工厂

     ```java
     public static Pizza createPizza(String type) {
         Pizza pizza = null;
         if (type.equals("greek")) {
             pizza = new GreekPizza();
             pizza.setName("greek");
         } else if (type.equals("cheese")) {
             pizza = new CheesePizza();
             pizza.setName("cheese");
         }
         return pizza;
     }
     ```

## 二，工厂方法模式

1. 基本介绍

   - 工厂方法模式设计方案：将披萨项目由实例化功能抽象成抽象方法，在不同的口味点餐子类中具体实现。
   - 工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的类。工厂方法模式将对象的实例化推迟到子类。

2. 披萨案例

   - 披萨抽象类

     ```java
     public abstract class Pizza {
         private String name;
     
         public abstract void prepare();
     
         public void make() {
             System.out.println("make " + name + " pizza");
         }
     
         public void cut() {
             System.out.println("cut " + name + " pizza");
         }
     
         public void box() {
             System.out.println("box " + name + " pizza");
         }
     
         public void setName(String name) {
             this.name = name;
         }
     }
     ```

   - 披萨实现类

     ```java
     public class BJCheesePizza extends Pizza {
         @Override
         public void prepare() {
             System.out.println("prepare Beijing's CheesePizza...");
         }
     }
     ```

     ```java
     public class BJGreekPizza extends Pizza {
         @Override
         public void prepare() {
             System.out.println("prepare Beijing's GreekPizza...");
         }
     }
     ```

     ......

   - 工厂抽象方法

     ```java
     public abstract class PizzaFactory {
         public abstract Pizza createPizza(String type);
     }
     ```

   - 工厂实现类

     ```java
     public class BJPizzaFactory extends PizzaFactory {
         @Override
         public Pizza createPizza(String type) {
             Pizza pizza = null;
             if (type.equals("greek")) {
                 pizza = new BJGreekPizza();
                 pizza.setName("Beijing's greek");
             } else if (type.equals("cheese")) {
                 pizza = new BJCheesePizza();
                 pizza.setName("Beijing's cheese");
             }
             return pizza;
         }
     }
     ```

     ```java
     public class LDPizzaFactory extends PizzaFactory {
         @Override
         public Pizza createPizza(String type) {
             Pizza pizza = null;
             if (type.equals("greek")) {
                 pizza = new LDGreekPizza();
                 pizza.setName("London's greek");
             } else if (type.equals("cheese")) {
                 pizza = new LDCheesePizza();
                 pizza.setName("London's cheese");
             }
             return pizza;
         }
     }
     ```

## 三，抽象工厂模式

1. 基本介绍

   - 抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类
   - 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。
   - 从设计层面看，抽象工模式就是对简单工厂模式的改进（或者称为进一步的抽象）。
   - 将工厂抽象成两层，AbsFactory(抽象工厂)和具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。

2. 披萨案例

   - 抽象工厂

     ```java
     public interface PizzaFactory {
         Pizza createPizza(String type);
     }
     ```

   - 使用

     ```java
     public class PizzaStore {
         public static void main(String[] args) {
             Scanner scanner = new Scanner(System.in);
             //使用时根据创建具体的实现类得到不同的工厂
             PizzaFactory factory = getFactory(new BJPizzaFactory());
             while (true) {
                 System.out.println("what pizza you want~~~");
                 String type = scanner.nextLine();
                 Pizza pizza = factory.createPizza(type);
                 if (pizza == null) {
                     break;
                 }
                 pizza.prepare();
                 pizza.make();
                 pizza.cut();
                 pizza.box();
                 System.out.println("----------------------");
             }
         }
     
         public static PizzaFactory getFactory(PizzaFactory pizzaFactory) {
             return pizzaFactory;
         }
     }
     ```

# 第五章 原型模式

1. 基本介绍

   - 原型模式(Prototype模式)是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象
   - 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节工作
   - 原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即对象.clone()

2. 通过继承Cloneable接口实现

   ```java
   public class Sheep implements Cloneable {
       private String name;
       private int age;
       private String color;
   
       public Sheep(String name, int age, String color) {
           this.name = name;
           this.age = age;
           this.color = color;
       }
   
       @Override
       public String toString() {
           return "Sheep{" +
                   "name='" + name + '\'' +
                   ", age=" + age +
                   ", color='" + color + '\'' +
                   '}';
       }
   
       @Override
       protected Sheep clone() {
           Sheep clone = null;
           try {
               clone = (Sheep) super.clone();
           } catch (CloneNotSupportedException e) {
               e.printStackTrace();
           }
           return clone;
       }
   }
   ```

3. 深拷贝

   - 通过重写clone方法实现深拷贝

     ```java
     public class Sheep implements Cloneable {
         public String name;
         public int age;
         public String color;
         public Sheep family;
     
         public Sheep(String name, int age, String color) {
             this.name = name;
             this.age = age;
             this.color = color;
         }
     
         @Override
         public String toString() {
             return "Sheep{" +
                     "name='" + name + '\'' +
                     ", age=" + age +
                     ", color='" + color + '\'' +
                     ", family=" + family +
                     '}';
         }
     
         @Override
         protected Sheep clone() {
             Sheep clone = null;
             try {
                 //先拷贝基本数据类型
                 clone = (Sheep) super.clone();
                 //拷贝对象
                 if (clone.family != null) {
                     clone.family = clone.family.clone();
                 }
             } catch (CloneNotSupportedException e) {
                 e.printStackTrace();
             }
             return clone;
         }
     }
     ```

   - 通过序列化方式

     ```java
     try  {
         ByteArrayOutputStream bos = new ByteArrayOutputStream();
         ObjectOutputStream oos = new ObjectOutputStream(bos);
         oos.writeObject(sheep);
     
         ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
         ObjectInputStream ois = new ObjectInputStream(bis);
         Sheep clone = (Sheep) ois.readObject();
     } catch (Exception e) {
         throw new RuntimeException(e);
     }
     ```

4. 注意事项和细节

   - 创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率
   - 不用重新初始化对象，而是动态地获得对象运行时的状态
   - 如果原始对象发生变化（增加或者减少属性），其它克隆对象的也会发生相应的变化，无需修改代码
   - 在实现深克隆的时候可能需要比较复杂的代码
   - 缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了ocp即原则











