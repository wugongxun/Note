# 第一章 七大设计原则

## 一，设计模式的目的

编写软件过程中，程序员面临着来自（耦合性）内聚性以及可维护性，可扩展性，重用性，灵活性等多方面的挑战，设计模式是为正程序（软件），具有更好

- 代码重用性
- 可读性
- 可扩展性
- 可靠性
- 高内聚，低耦合的特性

## 二，单一职责原则

1. 基本介绍

   对类来说的，即一个类应该只负责一如类A负责两个不同职责：职责1，职责2。当职责1需求变更而改变A时，可能造成职责2执行错误，所以需要将类A的粒度分解为 A1，A2

2. 案例

   - ```java
     //违反单一职责原则
     public class SingleResponsibility {
         public static void main(String[] args) {
             Vehicle vehicle = new Vehicle();
             vehicle.run("car");
             vehicle.run("plane");
         }
     }
     
     class Vehicle {
         public void run(String vehicle) {
             System.out.println(vehicle + " is running...");
         }
     }
     ```

   - ```java
     //遵守单一职责原则，但是改动太大
     public class SingleResponsibility {
         public static void main(String[] args) {
             RoadVehicle roadVehicle = new RoadVehicle();
             roadVehicle.run("car");
             AirVehicle airVehicle = new AirVehicle();
             airVehicle.run("plane");
         }
     }
     
     class RoadVehicle {
         public void run(String vehicle) {
             System.out.println(vehicle + " is running...");
         }
     }
     
     class AirVehicle {
         public void run(String vehicle) {
             System.out.println(vehicle + " is flying...");
         }
     }
     ```

3. 注意事项和细节
   - 降低类的复杂度，一个类只负责一项职责。
   - 提高类的可读性，可维护性
   - 降低变更引起的风险
   - 通常情沉下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则

## 三，接口隔离原则

1. 基本介绍

   客户端不应该依赖它不需要的接口，即一个类对另二个类的依赖应该建立在最小的接口上

2. 案例

   ```java
   interface Interface1 {
       void operation1();
   }
   
   interface Interface2 {
       void operation2();
       void operation3();
   }
   
   interface Interface3 {
       void operation4();
       void operation5();
   }
   
   class A {
       public void depend1(Interface1 i) {
           i.operation1();
       }
       public void depend2(Interface2 i) {
           i.operation2();
       }
       public void depend3(Interface2 i) {
           i.operation3();
       }
   }
   
   class C {
       public void depend1(Interface1 i) {
           i.operation1();
       }
       public void depend4(Interface3 i) {
           i.operation4();
       }
       public void depend5(Interface3 i) {
           i.operation5();
       }
   }
   
   class B implements Interface1, Interface2 {
       @Override
       public void operation1() {
           System.out.println("B 实现了 operation1");
       }
   
       @Override
       public void operation2() {
           System.out.println("B 实现了 operation2");
       }
   
       @Override
       public void operation3() {
           System.out.println("B 实现了 operation3");
       }
   }
   
   class D implements Interface1, Interface3 {
       @Override
       public void operation1() {
           System.out.println("D 实现了 operation1");
       }
   
       @Override
       public void operation4() {
           System.out.println("D 实现了 operation4");
       }
   
       @Override
       public void operation5() {
           System.out.println("D 实现了 operation5");
       }
   }
   ```

## 四，依赖倒转（倒置）原则

1. 基本介绍

   - 高层模块应该依赖低层模块，二者都应该依赖其抽象
   - 抽象不应该依赖细节，细节应该依赖抽象
   - 依赖倒转（倒置）的中心思想是面向接口编程
   - 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类
   - 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成

2. 案例

   ```java
   public class DependenceInversion {
       public static void main(String[] args) {
           Person person = new Person();
           person.receive(new Email());
           person.receive(new Message());
       }
   }
   
   interface Receivable {
       void getInfo();
   }
   
   class Email implements Receivable {
       @Override
       public void getInfo() {
           System.out.println("email info...");
       }
   }
   
   class Message implements Receivable {
       @Override
       public void getInfo() {
           System.out.println("message info...");
       }
   }
   
   class Person {
       public void receive(Receivable receivable) {
           receivable.getInfo();
       }
   }
   ```

3. 注意事项和细节

   - 低层模块尽量都要有抽象类或接口，或者两者都有，程序稳定性更好
   - 变量的声明类型尽量是抽象类或接口，这我们的变量引用和实际对象间，就存在一个缓冲层，利于程序扩展和优化
   - 继承时遵循里氏替换原则

## 五，里氏替换原则

1. 基本介绍
   - 如果对每个类型为T1的对象o1，都有类型为T2的对象o2,使得以T1定义的所有程序 P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象。在
   - 使用继承时，遵循里氏替换原则，在子类中尽量不要重写父类的方法
   - 里氏替换原则告诉我们，继承实际上让两个类耦合性增强了，在适当的情况下，可以通过聚合，组合，依赖来解决问题。

## 六，开闭原则

1. 基本介绍

   - 开闭原则(Open Closed Principle)是编程中最基础、最重要的设计原则
   - 一个软件实体如类，模块和函数应该对扩展开放，对修改关闭。用抽象构建框架，用实现扩展细节。
   - 当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。
   - 编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。

2. 案例

   ```java
   //违背OCP原则，如果需要添加新的图形，需要修改使用方
   public class Ocp {
       public static void main(String[] args) {
           GraphicEditor editor = new GraphicEditor();
           editor.drawShape(new Rectangle());
           editor.drawShape(new Circle());
       }
   }
   
   class Shape {
       int type;
   }
   
   class Rectangle extends Shape {
       public Rectangle() {
           super.type = 1;
       }
   }
   
   class Circle extends Shape {
       public Circle() {
           super.type = 2;
       }
   }
   
   class GraphicEditor {
       public void drawShape(Shape shape) {
           if (shape.type == 1) {
               System.out.println("绘制矩形");
           } else if (shape.type == 2) {
               System.out.println("绘制圆形");
           }
       }
   }
   ```

   ```java
   //符合ocp原则
   public class Ocp {
       public static void main(String[] args) {
           GraphicEditor editor = new GraphicEditor();
           editor.drawShape(new Rectangle());
           editor.drawShape(new Circle());
       }
   }
   
   abstract class Shape {
       abstract void draw();
   }
   
   class Rectangle extends Shape {
       @Override
       public void draw() {
           System.out.println("绘制矩形");
       }
   }
   
   class Circle extends Shape {
       @Override
       public void draw() {
           System.out.println("绘制圆形");
       }
   }
   
   class GraphicEditor {
       public void drawShape(Shape shape) {
           shape.draw();
       }
   }
   ```

## 七，迪米特法则

1. 基本介绍

   - 一个对象应该对其他对象保持最少的了解
   - 类与类关系越密切，耦合度越大
   - 迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的public方法，不对外泄露任何信息
   - 迪米特法则还有个更简单的定义：只与直接的朋友通信
   - ==直接的朋友==：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现**成员变量**，**方法参数**，**方法返回值**中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。

2. 案例

   ```java
   public class Demeter {
       public static void main(String[] args) {
           SchoolManager schoolManager = new SchoolManager();
           schoolManager.printAllEmployees(new EmployeeManager());
       }
   }
   
   class Employee {
       int id;
   }
   
   class EmployeeManager {
       public List<Employee> getEmployees() {
           ArrayList<Employee> employees = new ArrayList<>();
           for (int i = 0; i < 10; i++) {
               Employee employee = new Employee();
               employee.id = i;
               employees.add(employee);
           }
           return employees;
       }
   }
   
   class SchoolManager {
       public void printAllEmployees(EmployeeManager employeeManager) {
           //违反了迪米特法则，应为Employee不是SchoolManager的直接朋友，不应该直接使用Employee
           List<Employee> employees = employeeManager.getEmployees();
   
           for (Employee employee : employees) {
               System.out.println(employee.id);
           }
       }
   }
   ```

   ```java
   public class Demeter {
       public static void main(String[] args) {
           SchoolManager schoolManager = new SchoolManager();
           schoolManager.printAllEmployees(new EmployeeManager());
       }
   }
   
   class Employee {
       int id;
   }
   
   class EmployeeManager {
       public List<Employee> getEmployees() {
           ArrayList<Employee> employees = new ArrayList<>();
           for (int i = 0; i < 10; i++) {
               Employee employee = new Employee();
               employee.id = i;
               employees.add(employee);
           }
           return employees;
       }
   
       public void printAllEmployees() {
           List<Employee> employees = getEmployees();
   
           for (Employee employee : employees) {
               System.out.println(employee.id);
           }
       }
   }
   
   class SchoolManager {
       public void printAllEmployees(EmployeeManager employeeManager) {
           //遵守迪米特法则，EmployeeManager是SchoolManager的直接朋友，可以使用
           employeeManager.printAllEmployees();
       }
   }
   ```

3. 注意事项和细节

   - 迪米特法则的核心是降低类之间的耦合
   - 由于每个类都减少了不必要的依赖，因此迪米特法则只是要求降低类间（对象间）耦合关系，并不是要求完全没有依赖天系

## 八，合成复用原则

1. 基本介绍

   原则是尽量使用合成/聚合的方式，而不是使用继承

# 第二章 UML类图

## 一，基本介绍

1. UML——Unified modeling language UML(统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果
2. UML本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等
3. 使用UML来建模，常用的工具有Rational Rose，也可以使用一些插件来建模

## 二，类与类之间的关系

1. 依赖

   只要是类中使用到了对方，那么他们之间就存在依赖关系。如果没有对方，连编译都通过不了

   ![](F:\截图\屏幕截图 2023-04-11 160332.png)

2. 泛化

   泛化关系实际上就是继承关系，他是依赖关系的特例

   ![](F:\截图\屏幕截图 2023-04-11 160606.png)

3. 实现

   实现关系实际上就是A类实现了B类，他是依赖关系的特例

   ![](F:\截图\屏幕截图 2023-04-11 161045.png)

4. 关联

   关联关系实际上就是类与类之间的联系，他是依赖关系的特例

   关联具有导航性：即双向关系或单向关系

   关联具有多重性：如

5. 聚合

   聚合关系（Aggregation）表示的是整体和部分的关系，整体与部分可以分开。聚合关系是关联关系的特例，所以他具有关联关系的导航性与多重性

   如：一台电脑由键盘、显示器、鼠标等组成，组成电脑的各个配件是可以从电脑上分离出来的

   ![](F:\截图\屏幕截图 2023-04-11 161949.png)

6. 组合

   组合也是整体与部分的关系，但是整体与部分不可以分开

   ![](F:\截图\屏幕截图 2023-04-11 162355.png)

# 第三章 单例模式

1. 基本介绍

   所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（静态方法）。

2. 饿汉式（静态常量）

   - 构造器私有化

   - 类的内部创建对象

   - 对外暴露一个静态的公共方法

   - ```java
     class Singleton1 {
         //构造器私有化
         private Singleton1() {}
         //类的内部创建对象
         private final static Singleton1 instance = new Singleton1();
         //对外暴露一个静态的公共方法
         public static Singleton1 getInstance() {
             return instance;
         }
     }
     ```

   优缺点：

   - 这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。
   - 在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，在单例模式中大多数都是调用getInstance方法，但是导致类装载的原因有很多种，因此不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance就没有达到lazy loading的效果

3. 饿汉式（静态代码块）

   ```java
   class Singleton2 {
       private static Singleton2 instance;
       //构造器私有化
       private Singleton2() {}
       static {
           instance = new Singleton2();
       }
       //对外暴露一个静态的公共方法
       public static Singleton2 getInstance() {
           return instance;
       }
   }
   ```

4. 懒汉式（线程不安全）

   ```java
   class Singleton3 {
       private static Singleton3 instance;
       private Singleton3() {}
       public static Singleton3 getInstance() {
           if (instance == null) {
               instance = new Singleton3();
           }
           return instance;
       }
   }
   ```

   优缺点：

   - 起到了Lazy Loading的效果，但是只能在单线程下使用
   - 如果在多线程下，一个线程进入了if判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式

5. 懒汉式（线程安全，同步方法）

   ```java
   class Singleton4 {
       private static Singleton4 instance;
       private Singleton4() {}
       public synchronized static Singleton4 getInstance() {
           if (instance == null) {
               instance = new Singleton4();
           }
           return instance;
       }
   }
   ```

   优缺点：

   - 解决了线程不安全问题
   - 效率太低了，每个线程在想获得类的实例时侯候，执行getInstance()方法都要进行同步。而其实这个方法只执行一次实例化代码就够了，后面的想获得该类实例，直接return就行了。方法进行同步效率太低

6. 懒汉式（线程安全，双重检查）

   ```java
   class Singleton5 {
       private static volatile Singleton5 instance;
       private Singleton5() {}
       public static Singleton5 getInstance() {
           if (instance == null) {
               synchronized (Singleton5.class) {
                   if (instance == null) {
                       instance = new Singleton5();
                   }
               }
           }
           return instance;
       }
   }
   ```

   优缺点分析：

   - Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两次`if (instance = null)`检查，这样就可以保证线程安全了。
   - 这样，实例化代码只用执行一次，后面再次访问时，判断`if (singleton = null)`,直接return实例化对象，也避免的反复进行方法同步

7. 静态内部类

   ```java
   class Singleton6 {
       //构造器私有化
       private Singleton6() {}
       private static class Singleton {
           private static final Singleton instance = new Singleton();
       }
       public static Singleton getInstance() {
           return Singleton.instance;
       }
   }
   ```

   优缺点：

   - 这种方式采用了类装载的机制来保证初始化实例时只有一个线程。
   - 静态内部类方式在Singleton6类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载Singleton类，从而完成Singleton的实例化
   - 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。

8. 

